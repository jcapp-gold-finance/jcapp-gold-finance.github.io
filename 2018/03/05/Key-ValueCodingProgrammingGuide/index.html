<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Interpreter：戴奕

Apple 官方文档：《Key-Value Coding Programming》翻译一篇。文章稍微有点那么点长。">
<meta property="og:type" content="article">
<meta property="og:title" content="Key-Value Coding Programming 翻译一篇">
<meta property="og:url" content="http://yoursite.com/2018/03/05/Key-ValueCodingProgrammingGuide/index.html">
<meta property="og:site_name" content="金诚App团队blog">
<meta property="og:description" content="Interpreter：戴奕

Apple 官方文档：《Key-Value Coding Programming》翻译一篇。文章稍微有点那么点长。">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg">
<meta property="og:updated_time" content="2018-06-11T08:43:02.122Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Key-Value Coding Programming 翻译一篇">
<meta name="twitter:description" content="Interpreter：戴奕

Apple 官方文档：《Key-Value Coding Programming》翻译一篇。文章稍微有点那么点长。">
<meta name="twitter:image" content="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/05/Key-ValueCodingProgrammingGuide/"/>





  <title> Key-Value Coding Programming 翻译一篇 | 金诚App团队blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">金诚App团队blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Key-ValueCodingProgrammingGuide/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Key-Value Coding Programming 翻译一篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T11:04:12+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>Interpreter：戴奕</p>
</blockquote>
<p>Apple 官方文档：《Key-Value Coding Programming》翻译一篇。文章稍微有点那么点长。</p>
<a id="more"></a>
<h2 id="About-Key-Value-Coding"><a href="#About-Key-Value-Coding" class="headerlink" title="About Key-Value Coding"></a>About Key-Value Coding</h2><h2 id="关于键值编码"><a href="#关于键值编码" class="headerlink" title="关于键值编码"></a>关于键值编码</h2><p>Key-value coding is a mechanism enabled by the <code>NSKeyValueCoding</code> informal protocol that objects adopt to provide indirect access to their properties.When an object is key-value coding compliant, its properties are addressable via string parameters through a concise, uniform messaging interface.This indirect access mechanism supplements the direct access afforded by instance variables and their associated accessor methods.</p>
<p>键值编码是由<code>NSKeyValueCoding</code>非正式协议启用的一种机制，它能够提供一个对象间接访问属性的能力。当一个对象符合兼职编码时，它的属性可以通过一个简洁、统一的接口传递一个字符串参数访问。这种间接访问机制是对通过实例变量或者相关访问方法直接访问的补充。</p>
<p>You typically use accessor methods to gain access to an object’s properties. A get accessor (or getter) returns the value of a property. A set accessor (or setter) sets the value of a property. In Objective-C, you can also directly access a property’s underlying instance variable. Accessing an object property in any of these ways is straightforward, but requires calling on a property-specific method or variable name. As the list of properties grows or changes, so also must the code which accesses these properties. In contrast, a key-value coding compliant object provides a simple messaging interface that is consistent across all of its properties.</p>
<p>你通常使用访问方法去获得一个对象的属性。Getter 方法通常返回了一个属性的值。Setter 方法用来设置一个属性的值。在 Objective-C 中，你也可以直接访问一个属性底层的实例变量。用任意的这些方法去访问对象属性都是很简单的，但是必须要调用属性指定的方法或者变量名字。随着属性列表的增长或者改变，这些方法方法也必须作出改变。相反的，一个符合兼职编码的对象提供了一个简单的接口用来访问所有的属性。</p>
<p>Key-value coding is a fundamental concept that underlies many other Cocoa technologies, such as key-value observing, Cocoa bindings, Core Data, and AppleScript-ability. Key-value coding can also help to simplify your code in some cases.</p>
<p>键值编码是许多 Cocoa 技术的基础，比如 KVO, Cocoa bindings, Core Data, AppleScript-ability。键值编码技术也能在一些地方帮助你简化代码。</p>
<h3 id="Using-Key-Value-Coding-Compliant-Objects"><a href="#Using-Key-Value-Coding-Compliant-Objects" class="headerlink" title="Using Key-Value Coding Compliant Objects"></a>Using Key-Value Coding Compliant Objects</h3><h3 id="使用符合键值编码的对象"><a href="#使用符合键值编码的对象" class="headerlink" title="使用符合键值编码的对象"></a>使用符合键值编码的对象</h3><p>Objects typically adopt key-value coding when they inherit from <code>NSObject</code> (directly or indirectly), which both adopts the <code>NSKeyValueCoding</code> protocol and provides a default implementation for the essential methods. Such an object enables other objects, through a compact messaging interface, to do the following:</p>
<p>当一个对象直接或者间接地继承自 <code>NSObject</code> 时，通常都采用了键值编码，符合了 <code>NSKeyValueCoding</code> 协议并且默认实现了必要的方法。这样的对象通过一个紧凑的接口来使其他的对象实现以下的功能：</p>
<ul>
<li><strong>Access object properties.</strong> The protocol specifies methods, such as the generic getter <code>valueForKey:</code>and the generic setter <code>setValue:forKey:</code>, for accessing object properties by their name, or key, parameterized as a string. The default implementation of these and related methods use the key to locate and interact with the underlying data, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="external">Accessing Object Properties</a>.</li>
<li><strong>访问对象属性。</strong>协议指定了通用的访问方法 <code>valueForKey:</code> 和通用的设置方法 <code>setValue:forKey:</code>，通过将它们的属性名字或者键值作为字符串类型的参数传入。这些方法的默认实现使用键值来定位内部的数据，参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="external">Accessing Object Properties</a>。</li>
<li><strong>Manipulate collection properties.</strong> The default implementations of the access methods work with an object’s collection properties (such as <code>NSArray</code> objects) just like any other property. In addition, if an object defines collection accessor methods for a property, it enables key-value access to the contents of the collection. This is often more efficient than direct access and allows you to work with custom collection objects through a standardized interface, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessingCollectionProperties.html#//apple_ref/doc/uid/10000107i-CH4-SW1" target="_blank" rel="external">Accessing Collection Properties</a>.</li>
<li><strong>操作集合属性。</strong>这些方法的默认实现用来访问一个对象的集合属性（比如 <code>NSArray</code> 对象）时和其他属性是一样的。此外，如果一个对象为属性定义了集合访问方法，它也启用了键值编码对集合内容的访问。这往往比直接访问更加高效，并且它允许你通过标准化接口访问自定义集合对象，参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessingCollectionProperties.html#//apple_ref/doc/uid/10000107i-CH4-SW1" target="_blank" rel="external">Accessing Collection Properties</a>。</li>
<li><strong>Access non-object properties.</strong> The default implementation of the protocol detects non-object properties, including both scalars and structures, and automatically wraps and unwraps them as objects for use on the protocol interface, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>. In addition, the protocol declares a method allowing a compliant object to provide a suitable action for the case when a <code>nil</code> value is set on a non-object property through the key-value coding interface.</li>
<li><strong>访问非对象类型的属性。</strong>协议的默认实现会自动检测非对象类型的属性，比如基本数据类型和结构体，并且会自动将他们通过协议接口对它们进行包装和解包，参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>。另外，该协议声明了一种方法，可以使得在非对象属性上通过键值编码接口设置 <code>nil</code> 时提供合适的处理。</li>
<li><strong>Access properties by key path.</strong> When you have a hierarchy of key-value coding compliant objects, you can use key path based method calls to drill down, getting or setting a value deep within the hierarchy using a single call.</li>
<li><strong>通过关键路径访问属性。</strong>当你有一个具有键值编码兼容对象的层次结构时，你可以使用基于关键路径的方法调用，只需要调用一次即可获取或者设置深层次的值。</li>
</ul>
<h3 id="Adopting-Key-Value-Coding-for-an-Object"><a href="#Adopting-Key-Value-Coding-for-an-Object" class="headerlink" title="Adopting Key-Value Coding for an Object"></a>Adopting Key-Value Coding for an Object</h3><h3 id="为一个对象采用键值编码"><a href="#为一个对象采用键值编码" class="headerlink" title="为一个对象采用键值编码"></a>为一个对象采用键值编码</h3><p>In order to make your own objects key-value coding compliant, you ensure that they adopt the <code>NSKeyValueCoding</code> informal protocol and implement the corresponding methods, such as <code>valueForKey:</code> as a generic getter and <code>setValue:forKey:</code> as a generic setter. Fortunately, as described above, <code>NSObject</code> adopts this protocol and provides default implementations for these and other essential methods. Therefore, if you derive your objects from <code>NSObject</code> (or any of its many subclasses), much of the work is already done for you.</p>
<p>为了使你自己的对象兼容键值编码，你需要确保对象采用了 <code>NSKeyValueCoding</code> 协议并且实现了相应的方法，比如通用获取方法 <code>valueForKey:</code> 和通用设置方法 <code>setValue:forKey:</code>。幸运的是，如上所述，<code>NSObject</code> 已经采用了该协议并提供了必要方法的默认实现。因此，如果你的对象是从 <code>NSObject</code> 继承过来的，那么大部分工作都已经完成了。</p>
<p>In order for the default methods to do their work, you ensure your object’s accessor methods and instance variables adhere to certain well-defined patterns. This allows the default implementation to find your object’s properties in response to key-value coded messages. You then optionally extend and customize key-value coding by providing methods for validation and for handling certain special cases.</p>
<p>为了确保默认方法能够顺利执行，你必须确保你的访问方法和实例变量符合一些明确的定义。这允许默认的方法实现可以寻找到对象的属性以响应键值编码的消息。你可以通过提供的方法扩展和自定义键值编码来处理一些特殊情况。</p>
<h3 id="Key-Value-Coding-with-Swift"><a href="#Key-Value-Coding-with-Swift" class="headerlink" title="Key-Value Coding with Swift"></a>Key-Value Coding with Swift</h3><h3 id="Swift-中的键值编码"><a href="#Swift-中的键值编码" class="headerlink" title="Swift 中的键值编码"></a>Swift 中的键值编码</h3><p>Swift objects that inherit from <code>NSObject</code> or one of its subclasses are key-value coding compliant for their properties by default. Whereas in Objective-C, a property’s accessors and instance variables must follow certain patterns, a standard property declaration in Swift automatically guarantees this. On the other hand, many of the protocol’s features are either not relevant or are better handled using native Swift constructs or techniques that do not exist in Objective-C. For example, because all Swift properties are objects, you never exercise the default implementation’s special handling of non-object properties.</p>
<p>从 <code>NSObject</code> 继承过来的 Swift 对象的属性默认情况下是符合键值编码的。在 Objective-C 中，属性的访问方法和实例变量必须遵循一些模式，Swift 中属性的标准声明自动保证了这一点。另一方面，许多协议的功能要么不相关，要么使用 Objective-C 中不存在的 Swift 结构体或技术进行更好的处理。举个例子，由于 Swift 中所有的属性都是对象，所以在默认的方法实现中，你永远不会对非对象的属性进行特殊处理。</p>
<p>Therefore, while the key-value coding protocol methods translate straightforwardly to Swift, this guide focuses primarily on Objective-C, where you need to do more to ensure compliance, and where key-value coding is often most useful. Situations that call for a significantly different approach in Swift are noted throughout the guide.</p>
<p>因此，尽管键值编码协议和方法能够直接转换给 Swift，这篇指南还是主要关注 Objective-C，你需要做更多的工作来保证兼容性，以及键值编码通常最有用的地方。在指南中指出了 Swift 需要采用不同方法的情况。</p>
<p>For more information about using Swift with Cocoa technologies, read <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a>. For a complete description of Swift, read <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a>.</p>
<p>有关在 Cocoa 技术中使用 Swift ，参阅 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a>。有关完整的 Swift 描述，参阅 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a> 。</p>
<h3 id="Other-Cocoa-Technologies-Rely-on-Key-Value-Coding"><a href="#Other-Cocoa-Technologies-Rely-on-Key-Value-Coding" class="headerlink" title="Other Cocoa Technologies Rely on Key-Value Coding"></a>Other Cocoa Technologies Rely on Key-Value Coding</h3><h3 id="Cocoa-中其他依赖键值编码的技术"><a href="#Cocoa-中其他依赖键值编码的技术" class="headerlink" title="Cocoa 中其他依赖键值编码的技术"></a>Cocoa 中其他依赖键值编码的技术</h3><p>An object that is key-value coding compliant can participate in a wide range of Cocoa technologies that depend upon this kind of access, including:</p>
<p>一个符合键值编码的对象可以参与多种 Cocoa 中依赖于这些访问的技术，包括：</p>
<ul>
<li><strong>Key-value observing.</strong> This mechanism enables objects to register for asynchronous notifications driven by changes in another object’s properties, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>.</li>
<li><strong>键值观察。</strong>该机制允许对象注册由其他对象的属性改变而驱动的异步通知，正如 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a> 中描述。</li>
<li><strong>Cocoa bindings.</strong> This collection of technologies fully implement a Model-View-Controller paradigm, where models encapsulate application data, views display and edit that data, and controllers mediate between the two. Read <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i" target="_blank" rel="external"><em>Cocoa Bindings Programming Topics</em></a> to learn more about Cocoa Bindings.</li>
<li><strong>Cocoa 绑定。</strong>这一系列基础完全实现了 MVC 范式，模型封装数据，视图展示并且修改数据，控制器处理两者。了解更多的 Cocoa 绑定技术，请阅读 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i" target="_blank" rel="external"><em>Cocoa Bindings Programming Topics</em></a> 。</li>
<li><strong>Core Data.</strong> This framework provides generalized and automated solutions to common tasks associated with object life cycle and object graph management, including persistence. You can read about Core Data in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external"><em>Core Data Programming Guide</em></a>.</li>
<li><strong>Core Data。</strong>该框架为对象声明周期和对象图管理等相关任务提供了通用的自动化解决方案。你可以阅读  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external"><em>Core Data Programming Guide</em></a> 了解更多。</li>
<li><strong>AppleScript.</strong> This scripting language enables direct control of scriptable apps and of many parts of macOS. Cocoa’s scripting support takes advantage of key-value coding to get and set information in scriptable objects. The methods in the <code>NSScriptKeyValueCoding</code> informal protocol provide additional capabilities for working with key-value coding, including getting and setting key values by index in multi-value keys and coercing (or converting) a key-value to the appropriate data type. <a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i" target="_blank" rel="external"><em>AppleScript Overview</em></a> provides a high-level overview of AppleScript and its related technologies.</li>
<li><strong>苹果脚本。</strong>该脚本语言可以直接控制可以编写脚本的应用，以及 macOS 上的许多部分。Cocoa 的脚本支持利用键值编码来获取或者设置脚本对象中的信息。在 <code>NSScriptKeyValueCoding</code> 非正式协议中的方法为键值编码提供了附加功能，包括通过多键值中的下标来设置和获取键值并强转成适当的数据类型。<a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i" target="_blank" rel="external"><em>AppleScript Overview</em></a> 提供了 AppleScript 及其相关技术的高级概述。</li>
</ul>
<h2 id="Accessing-Object-Properties"><a href="#Accessing-Object-Properties" class="headerlink" title="Accessing Object Properties"></a>Accessing Object Properties</h2><h2 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h2><p>An object typically specifies <em>properties</em> in its interface declaration, and these properties belong to one of several categories:</p>
<p>一个对象通常将它的属性在接口文件中声明，这些属性属于几个类别之一：</p>
<ul>
<li><strong>Attributes.</strong> These are simple values, such as a scalars, strings, or Boolean values. Value objects such as <code>NSNumber</code> and other immutable types such as as <code>NSColor</code> are also considered attributes.</li>
<li><strong>属性。</strong>这些是简单的值，比如基本数据类型，字符串，Boolean值。值对象的比如 <code>NSNumber</code> 以及其他不可变的比如 <code>NSColor</code> 等类型也被视为属性。</li>
<li><strong>To-one relationships.</strong> These are mutable objects with properties of their own. An object’s properties can change without the object itself changing. For example, a bank account object might have an owner property that is an instance of a <code>Person</code> object, which itself has an address property. The owner’s address may change without changing the owner reference held by the bank account. The bank account’s owner did not change. Only her address did.</li>
<li><strong>一对一关系。</strong>这些是具有属性的可变对象。对象的属性可以在对象本身不改变的情况下改变。例如，银行账户对象可能拥有一个 <code>Person</code> 类型的对象作为它的 所有者 属性，该属性自身拥有一个 地址 属性。所有者 属性的地址可以在该银行账户所有的所有者属性不变的情况下改变。银行账户所有者并没有改变。只有银行账户所有者的地址改变了。</li>
<li><strong>To-many relationships.</strong> These are collection objects. You commonly use an instance of <code>NSArray</code> or <code>NSSet</code> to hold such a collection, although custom collection classes are also possible.</li>
<li><strong>一对多关系。</strong>这些是集合对象。你通常使用 <code>NSArray</code> 或者 <code>NSSet</code> 的实例来保存这样一个集合，当然也可以使用自定义集合对象。</li>
</ul>
<p>The <code>BankAccount</code> object declared in Listing 2-1 demonstrates one of each type of property.</p>
<p>2-1 中的 <code>BankAccount</code> 对象指明了所有的属性以及类型。</p>
<p><strong>Listing 2-1 </strong>Properties of the <code>BankAccount</code> object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface BankAccount : NSObject</div><div class="line"> </div><div class="line">@property (nonatomic) NSNumber* currentBalance;              // An attribute</div><div class="line">@property (nonatomic) Person* owner;                         // A to-one relation</div><div class="line">@property (nonatomic) NSArray&lt; Transaction* &gt;* transactions; // A to-many relation</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>In order to maintain encapsulation, an object typically provides accessor methods for the properties on its interface. The object’s author may write these methods explicitly or may rely on the compiler to synthesize them automatically. Either way, the author of code using one of these accessors must write the property name into the code before compiling it. The name of the accessor method becomes a static part of the code that is using it. For example, given the bank account object declared in Listing 2-1, the compiler synthesizes a setter that you can invoke for the <code>myAccount</code> instance:</p>
<p>为了保证良好的封装性，一个对象通常会在它的接口中为属性提供访问方法。该对象的作者可能会明确地写出这些方法或者依赖编译器自动合成这些方法。无论哪种方式，使用这些访问方法的作者都必须在编译之前将属性名字写入代码中。访问器的方法名成为了使用它的代码的静态部分。例如，清单 2-1 中的银行账户对象，编译器会自动合成一个设置方法，因此你可以使用 <code>myAccount</code> 对象这样来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myAccount setCurrentBalance:@(100.0)];</div></pre></td></tr></table></figure>
<p>This is direct, but lacks flexibility. A key-value coding compliant object, on the other hand, offers a more general mechanism to access an object’s properties using string identifiers.</p>
<p>这是直接的，但是缺乏扩展性。另一方面，符合键值编码的对象提供了一种更通用的使用字符串来访问属性的方法。</p>
<h3 id="Identifying-an-Object’s-Properties-with-Keys-and-Key-Paths"><a href="#Identifying-an-Object’s-Properties-with-Keys-and-Key-Paths" class="headerlink" title="Identifying an Object’s Properties with Keys and Key Paths"></a>Identifying an Object’s Properties with Keys and Key Paths</h3><h3 id="用键和关键路径确定对象的属性"><a href="#用键和关键路径确定对象的属性" class="headerlink" title="用键和关键路径确定对象的属性"></a>用键和关键路径确定对象的属性</h3><p>A <em>key</em> is a string that identifies a specific property. Typically, by convention, the key representing a property is the name of the property itself as it appears in code. Keys must use ASCII encoding, may not contain whitespace, and usually begin with a lowercase letter (though there are exceptions, such as the <code>URL</code> property found in many classes).</p>
<p>一个用来指明属性的字符串类型的键。通常，按照约定，表示属性的键是在代码中出现的属性本身的名称。键必须使用 ASCII 编码，不能包含空格，通常以小写字母开头（也有例外，比如许多类中的 <code>URL</code> 属性）。</p>
<p>Because the <code>BankAccount</code> class in Listing 2-1 is key-value coding compliant, it recognizes the keys <code>owner</code>, <code>currentBalance</code>, and <code>transactions</code>, which are the names of its properties. Instead of calling the <code>setCurrentBalance:</code> method, you can set the value by its key:</p>
<p>由于清单 2-1 中的 <code>BankAccount</code> 类符合键值编码，它能识别比如 <code>owner</code>，<code>currentBalance</code>，<code>transactions</code> 这些原本就是属性名字的 key。你可以使用设置这个 key 值来取代调用 <code>setCurrentBalance:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</div></pre></td></tr></table></figure>
<p>In fact, you can set all the properties of the <code>myAccount</code> object with the same method, using different key parameters. Because the parameter is a string, it can be a variable that is manipulated at run-time.</p>
<p>实际上，你可以通过该方法使用不同的 key 值作为参数设置 <code>myAccount</code> 对象的所有属性。由于参数是个字符串，所以它可以在运行时操作变量。</p>
<p>A <em>key path</em> is a string of dot-separated keys used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver, and each subsequent key is evaluated relative to the value of the previous property. Key paths are useful for drilling down into a hierarchy of objects with a single method call.</p>
<p>以点号分割的关键路径用来指定要遍历的对象属性序列。序列中第一个键的属性是相对于接收者的，并且每个后续键都相对于前一个属性的值来指定。关键路径对于用单次调用深入到对象的层次结构非常有用。</p>
<p>For example, the key path <code>owner.address.street</code> applied to a bank account instance refers to the value of the street string that is stored in the address of the bank account’s owner, assuming the <code>Person</code> and <code>Address</code>classes are also key-value coding compliant.</p>
<p>例如，应用于银行账户实例的 <code>owner.address.street</code> 关键路径指的是 银行账户 的 拥有者 的 地址 里的 街道 的值，假设 <code>Person</code> 和 <code>Address</code> 类都是符合键值编码的。</p>
<blockquote>
<p>NOTE</p>
<p>In Swift, instead of using a string to indicate a key or key path, you can use a <code>#keyPath</code> expression. This offers the advantage of a compile time check, as described in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" target="_blank" rel="external">Keys and Key Paths</a> section of the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a> guide.</p>
<p>注意</p>
<p>在 Swift 中，不是用字符串来表示键或者关键路径，你可以使用 <code>#keyPath</code> 来表示。这提供了在编译时检查的有点，如 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a>  中的 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" target="_blank" rel="external">Keys and Key Paths</a> 章节所述。</p>
</blockquote>
<h3 id="Getting-Attribute-Values-Using-Keys"><a href="#Getting-Attribute-Values-Using-Keys" class="headerlink" title="Getting Attribute Values Using Keys"></a>Getting Attribute Values Using Keys</h3><h3 id="使用键获取属性值"><a href="#使用键获取属性值" class="headerlink" title="使用键获取属性值"></a>使用键获取属性值</h3><p>An object is key-value coding compliant when it adopts the <code>NSKeyValueCoding</code> protocol. An object that inherits from <code>NSObject</code>, which provides a default implementation of the protocol’s essential methods, automatically adopts this protocol with certain default behaviors. Such an object implements at least the following basic key-based getters:</p>
<p>当一个对象采用 <code>NSKeyValueCoding</code> 协议时该对象就兼容了键值编码。从提供协议基本实现的 <code>NSObject</code> 类继承而来的一个对象，会自动采用该协议的一些默认行为。这样的对象至少实现了以下基于键实现的获取方法：</p>
<ul>
<li><code>valueForKey:</code> - Returns the value of a property named by the key parameter. If the property named by the key cannot be found according to the rules described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a>, then the object sends itself a <code>valueForUndefinedKey:</code> message. The default implementation of <code>valueForUndefinedKey:</code>raises an <code>NSUndefinedKeyException</code>, but subclasses may override this behavior and handle the situation more gracefully.</li>
<li><code>valueForKey:</code> - 返回与参数同名的属性值。如果根据 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a> 规则无法找到该键所对应的属性，那么该对象就会向自身发送一个 <code>valueForUndefinedKey:</code> 消息。<code>valueForUndefinedKey:</code> 方法的默认实现会抛出一个 <code>NSUndefinedKeyException</code> 异常，但是子类可能重写了该方法从而能够更优雅地处理该情况。</li>
<li><code>valueForKeyPath:</code> - Returns the value for the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key—that is, for which the default implementation of <code>valueForKey:</code> cannot find an accessor method—receives a <code>valueForUndefinedKey:</code> message.</li>
<li><code>valueForKeyPath:</code> - 返回相对于接收者的指定键路径的值。在这个键路径查找的对象序列中，一旦有一个对象不符合键值编码，也就是说 <code>valueForKey:</code> 方法无法找到对应的方法，那么它将会收到 <code>valueForUndefinedKey</code> 消息。</li>
<li><code>dictionaryWithValuesForKeys:</code> - Returns the values for an array of keys relative to the receiver. The method calls <code>valueForKey:</code> for each key in the array. The returned <code>NSDictionary</code> contains values for all the keys in the array.</li>
<li><code>dictionaryWithValuesForKeys:</code> - 以字典形式返回与所有键一一对应的值。该方法会根据键数组向接收者逐一发送 <code>valueForKey:</code> 消息。返回的数组里包含了与所有键一一对应的值。</li>
</ul>
<blockquote>
<p>NOTE</p>
<p>Collection objects, such as <code>NSArray</code>, <code>NSSet</code>, and <code>NSDictionary</code>, can’t contain <code>nil</code> as a value. Instead, you represent <code>nil</code> values using the <code>NSNull</code> object. <code>NSNull</code> provides a single instance that represents the <code>nil</code>value for object properties. The default implementations of <code>dictionaryWithValuesForKeys:</code> and the related <code>setValuesForKeysWithDictionary:</code> translate between <code>NSNull</code> (in the dictionary parameter) and <code>nil</code> (in the stored property) automatically.</p>
<p>注意</p>
<p>集合对象无法将 <code>nil</code> 作为值，比如 <code>NSArray</code>, <code>NSSet</code>, 和 <code>NSDictionary</code>。因此，这里使用 <code>NSNull</code> 对象来替代 <code>nil</code> 存入集合中。<code>NSNull</code> 是用来代表对象属性为 <code>nil</code> 的一个单例对象。在<code>dictionaryWithValuesForKeys:</code> 和相关的 <code>setValuesForKeysWithDictionary:</code> 两个方法的默认实现中会将 <code>NSNull</code> 和对象属性的 <code>nil</code> 自动进行转换。</p>
</blockquote>
<p>When you use a key path to address a property, if any but the final key in the key path is a to-many relationship (that is, it references a collection), the returned value is a collection containing all the values for the keys to the right of the to-many key. For example, requesting the value of the key path <code>transactions.payee</code> returns an array containing all the <code>payee</code> objects for all the transactions. This also works for multiple arrays in the key path. The key path <code>accounts.transactions.payee</code> returns an array with all the payee objects for all the transactions in all the accounts.</p>
<p>如果使用键路径去访问属性，并且键路径的最后一个键是多对多关系（即引用的是一个容器），那么返回值是一个包含所有键和所有值的集合。例如，请求键路径为 <code>transactions.payee</code> 时，返回值是包含所有 transaction 的 <code>payee</code> 属性值的数组。键路径如果有多个数组也同样适用。<code>accounts.transactions.payee</code> 这一键路径会返回所有 账户下 的所有 交易的 <code>payee</code> 属性的值。</p>
<h3 id="Setting-Attribute-Values-Using-Keys"><a href="#Setting-Attribute-Values-Using-Keys" class="headerlink" title="Setting Attribute Values Using Keys"></a>Setting Attribute Values Using Keys</h3><h3 id="使用键设置属性值"><a href="#使用键设置属性值" class="headerlink" title="使用键设置属性值"></a>使用键设置属性值</h3><p>As with getters, key-value coding compliant objects also provide a small group of generalized setters with default behavior based upon the implementation of the <code>NSKeyValueCoding</code> protocol found in <code>NSObject</code>:</p>
<p>兼容键值编码的对象同时也提供了 <code>NSKeyValueCoding</code> 协议中一部分设置相关的方法的默认实现：</p>
<ul>
<li><code>setValue:forKey:</code> - Sets the value of the specified key relative to the object receiving the message to the given value. The default implementation of <code>setValue:forKey:</code> automatically unwraps <code>NSNumber</code> and <code>NSValue</code> objects that represent scalars and structs and assigns them to the property. See <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> for details on the wrapping and unwrapping semantics.If the specified key corresponds to a property that the object receiving the setter call does not have, the object sends itself a <code>setValue:forUndefinedKey:</code> message. The default implementation of <code>setValue:forUndefinedKey:</code> raises an <code>NSUndefinedKeyException</code>. However, subclasses may override this method to handle the request in a custom manner.</li>
<li><code>setValue:forKey:</code> - 使用指定的键和给定值赋值给接收消息的对象的指定的属性。<code>setValue:forKey:</code> 的默认实现会自动将 <code>NSNumber</code> 和 <code>NSValue</code>  对象展开为基本数据类型和结构体再赋值给属性。有关包装和解包的详细信息请参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 。如果在对象中没有指定键所对应的属性，那么该对象会向自己发送 <code>setValue:forUndefinedKey:</code> 消息。<code>setValue:forUndefinedKey:</code> 默认实现是抛出一个 <code>NSUndefinedKeyException</code> 异常。当然子类可以重写该方法进行自定义处理。</li>
<li><code>setValue:forKeyPath:</code> - Sets the given value at the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key receives a <code>setValue:forUndefinedKey:</code> message.</li>
<li><code>setValue:forKeyPath:</code> - 根据跟定的值设置相对于接收者的键路径的值。该键路径序列中的任意一个对象如果没有兼容键值编码，则会收到 <code>setValue:forUndefinedKey:</code> 消息。</li>
<li><code>setValuesForKeysWithDictionary:</code> - Sets the properties of the receiver with the values in the specified dictionary, using the dictionary keys to identify the properties. The default implementation invokes <code>setValue:forKey:</code> for each key-value pair, substituting <code>nil</code> for <code>NSNull</code> objects as required.</li>
<li><code>setValuesForKeysWithDictionary:</code> - 使用字典里的键和对应的值设置接收者对应的属性。该方法的默认实现会使用 <code>setValue:forKey:</code> 方法设置每个键对应的属性，需要设置 <code>nil</code> 的属性则在字典中用 <code>NSNull</code> 代替。</li>
</ul>
<p>In the default implementation, when you attempt to set a non-object property to a <code>nil</code> value, the key-value coding compliant object sends itself a <code>setNilValueForKey:</code> message. The default implementation of <code>setNilValueForKey:</code> raises an <code>NSInvalidArgumentException</code>, but an object may override this behavior to substitute a default value or a marker value instead, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a>.</p>
<p>当你尝试向一个非对象类型的属性设置 <code>nil</code> 时，键值编码的默认实现会向该对象发送 <code>setNilValueForKey:</code> 消息。<code>setNilValueForKey:</code> 消息的默认实现会抛出一个 <code>NSInvalidArgumentException</code> 异常，当然可以覆盖此行为来设置默认值或者一个标记值，参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a>。</p>
<h3 id="Using-Keys-to-Simplify-Object-Access"><a href="#Using-Keys-to-Simplify-Object-Access" class="headerlink" title="Using Keys to Simplify Object Access"></a>Using Keys to Simplify Object Access</h3><h3 id="使用键来简化对象访问"><a href="#使用键来简化对象访问" class="headerlink" title="使用键来简化对象访问"></a>使用键来简化对象访问</h3><p>To see how key-based getters and setters can simplify your code, consider the following example. In macOS, <code>NSTableView</code> and <code>NSOutlineView</code> objects associate an identifier string with each of their columns. If the model object backing the table is not key-value coding compliant, the table’s data source method is forced to examine each column identifier in turn to find the correct property to return, as shown in Listing 2-2. Further, in the future, when you add another property to your model, in this case the <code>Person</code> object, you must also revisit the data source method, adding another condition to test for the new property and return the relevant value.</p>
<p>查看下面的例子可以了解如何使用键值编码来简化你的代码。在 macOS 中， <code>NSTableView</code> 和 <code>NSOutlineView</code> 这两个对象会使用字符串标志和每一列相关联。如果该表格中的模型对象不符合键值编码，那么该表格的数据源方法会强制依次检查每个列的标志，直到返回正确属性，如清单2-2所示。此外，当你向你的模型添加另一个属性时，在这里例子中是 <code>Person</code> ，你必须重新访问数据源方法，添加另一个条件来测试新属性并返回相关的值。</p>
<p><strong>Listing 2-2 </strong> Implementation of data source method without key-value coding</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">    id result = nil;</div><div class="line">    Person *person = [self.people objectAtIndex:row];</div><div class="line"> </div><div class="line">    if ([[column identifier] isEqualToString:@&quot;name&quot;]) &#123;</div><div class="line">        result = [person name];</div><div class="line">    &#125; else if ([[column identifier] isEqualToString:@&quot;age&quot;]) &#123;</div><div class="line">        result = @([person age]);  // Wrap age, a scalar, as an NSNumber</div><div class="line">    &#125; else if ([[column identifier] isEqualToString:@&quot;favoriteColor&quot;]) &#123;</div><div class="line">        result = [person favoriteColor];</div><div class="line">    &#125; // And so on...</div><div class="line"> </div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>On the other hand, Listing 2-3 shows a much more compact implementation of the same data source method that takes advantage of a key-value coding compliant <code>Person</code> object. Using only the <code>valueForKey:</code> getter, the data source method returns the appropriate value using the column identifier as a key. In addition to being shorter, it is also more general, because it continues to work unchanged when new columns are added later, as long as the column identifiers always match the model object’s property names.</p>
<p>相反的，在清单 2-3 中展示了一种利用键值编码特性来实现更简洁的实现 <code>Person</code> 对象数据源方法。只使用 <code>valueForKey:</code> 方法就可以在数据源方法中使用每一列的标志返回合适的值。除了更短之外，这样子更加通用，当后续添加新的列时，只要列的标志和对象的属性名字匹配即可，无需改动代码。</p>
<p><strong>Listing 2-3 </strong>Implementation of data source method with key-value coding</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row</div><div class="line">&#123;</div><div class="line">    return [[self.people objectAtIndex:row] valueForKey:[column identifier]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Accessing-Collection-Properties"><a href="#Accessing-Collection-Properties" class="headerlink" title="Accessing Collection Properties"></a>Accessing Collection Properties</h2><h2 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h2><p>Key-value coding compliant objects expose their to-many properties in the same way that they expose other properties. You can get or set a collection object just as you would any other object using <code>valueForKey:</code> and <code>setValue:forKey:</code> (or their key path equivalents). However, when you want to manipulate the content of these collections, it’s usually most efficient to use the mutable proxy methods defined by the protocol.</p>
<p>键值编码对象以与暴露其他属性相同的方式暴露一对多属性。你可以像其他对象一样使用 <code>valueForKey:</code> 和 <code>setValue:forKey:</code> 来获取和设置容器对象（或者关键路径）。然而，当你想操作这些集合的内容时，使用协议定义的代理方法通常最有效。</p>
<p>The protocol defines three different proxy methods for collection object access, each with a key and a key path variant:</p>
<p>协议为访问集合对象定义了三种使用键/键路径来访问的代理方法：</p>
<ul>
<li><p><code>mutableArrayValueForKey:</code> and <code>mutableArrayValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableArray</code> object.</p>
<p>这两个方法返回一个与 <code>NSMutableArray</code> 类似的代理对象。</p>
</li>
<li><p><code>mutableSetValueForKey:</code> and <code>mutableSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableSet</code> object.</p>
<p>这两个方法返回一个与 <code>NSMutableSet</code> 类似的代理对象。</p>
</li>
<li><p><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableOrderedSet</code> object.</p>
<p>这两个方法返回一个与 <code>NSMutableOrderedSet</code> 类似的代理对象。</p>
</li>
</ul>
<p>When you operate on the proxy object, adding objects to, removing objects from, or replacing objects in it, the default implementation of the protocol modifies the underlying property accordingly. This is more efficient than obtaining a non-mutable collection object with <code>valueForKey:</code>, creating a modified one with altered content, and then storing it back to the object with a <code>setValue:forKey:</code> message. In many cases, it is also more efficient than working directly with a mutable property. These methods provide the additional benefit of maintaining key-value observing compliance for the objects held in the collection object (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a> for details.</p>
<p>当你在代理对象上进行添加，删除，替换对象等操作时，协议的默认实现是修改相应的底层属性。创建一个修改内容后的对象并通过 <code>setValue:forKey:</code> 存储会原来的对象，这比使用 <code>valueForKey:</code> 获取不可变对象更高效。在许多情况下，这笔直接使用可变属性更高效。这些方法在集合对象中保留键值观察对象时提供额外的好处（参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a> 获取更多）。</p>
<h2 id="Using-Collection-Operators"><a href="#Using-Collection-Operators" class="headerlink" title="Using Collection Operators"></a>Using Collection Operators</h2><h2 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h2><p>When you send a key-value coding compliant object the <code>valueForKeyPath:</code> message, you can embed a <em>collection operator</em> in the key path. A collection operator is one of a small list of keywords preceded by an at sign (<code>@</code>) that specifies an operation that the getter should perform to manipulate the data in some way before returning it. The default implementation of <code>valueForKeyPath:</code> provided by <code>NSObject</code> implements this behavior.</p>
<p>当你向一个键值编码对象发送 <code>valueForKeyPath:</code> 消息的时候，你可以在关键路径中嵌入集合运算符。一个集合运算符是一个以 <code>@</code> 开头的小关键字列表之一，它指定了获取方法在返回数据之前进行某种指定的操作。<code>NSObject</code> 所提供 <code>valueForKeyPath:</code> 的默认实现已经具备了该行为。</p>
<p>When a key path contains a collection operator, any portion of the key path preceding the operator, known as the <em>left key path</em>, indicates the collection on which to operate relative to the receiver of the message. If you send the message directly to a collection object, such as an <code>NSArray</code> instance, the left key path may be omitted.</p>
<p>当关键路径包含集合运算符时，运算符之前的关键路径的任何部分，即左边部分，是集合运算符进行操作的部分。如果你直接发送（包含集合运算符）的消息给容器对象，比如 <code>NSArray</code> ，那么左边路径即可省略。</p>
<p>The portion of the key path after the operator, known as the <em>right key path</em>, specifies the property within the collection that the operator should work on. All the collection operators except <code>@count</code> require a right key path. Figure 4-1 illustrates the operator key path format.</p>
<p>在集合运算符之后的路径，即右边的路径，指定了集合对象中被操作的属性。所有集合运算符中，除了 <code>@count</code> 之外都需要右边路径。图 4-1说明了集合运算符操作路径的格式。</p>
<p><strong>Figure 4-1</strong>Operator key path format</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt="4-1"></p>
<p>Collection operators exhibit three basic types of behavior:</p>
<p>集合运算符展示了三种基本基本行为：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW5" target="_blank" rel="external">Aggregation Operators</a> coalesce a collection’s objects in some way, and return a single object that generally matches the data type of the property named in the right key path. The <code>@count</code> operator is an exception—it takes no right key path and always returns an <code>NSNumber</code> instance.</li>
<li>聚合操作会使用某种方式将集合对象进行合并，并返回一个与集合运算符右边关键路径所指定的属性类型一致的对象。<code>@count</code> 操作符是个例外，它没有右边路径，返回的是一个 <code>NSNumber</code> 类型的对象。</li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW7" target="_blank" rel="external">Array Operators</a> return an <code>NSArray</code> instance containing some subset of the objects held in the named collection.</li>
<li>数组操作返回一个 <code>NSArray</code> 对象，该对象是一个包含指定集合中某些对象的子集。</li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW9" target="_blank" rel="external">Nesting Operators</a> work on collections that contain other collections, and return an <code>NSArray</code> or <code>NSSet</code>instance, depending on the operator, that combines the objects of the nested collections in some way.</li>
<li>嵌套操作处理包含其他集合的集合，并返回一个 <code>NSArray</code> 或 <code>NSSet</code> 的对象，它以某种方式组合嵌套集合的对象，具体取决于该操作符。</li>
</ul>
<h3 id="Sample-Data"><a href="#Sample-Data" class="headerlink" title="Sample Data"></a>Sample Data</h3><p>The descriptions that follow include code snippets demonstrating how you invoke each operator, and the result of doing so. These rely on the <code>BankAccount</code> class, presented in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-SW1" target="_blank" rel="external">Listing 2-1</a>, which holds an array of <code>Transaction</code> objects. Each of these represents a simple checkbook entry, as declared in Listing 4-1.</p>
<p>以下的代码片段展示了如何每个集合操作符，以及使用后的结果。这依赖于清单 2-1 中列列出的 <code>BankAccount</code> 类，该类包含了一个内容为 <code>Transaction</code> 对象的数组。每一个 <code>Transaction</code> 对象都包含了一个简单的交易信息，如清单 4-1 所示。</p>
<p><strong>Listing 4-1</strong> Interface declaration for the <code>Transaction</code> object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface Transaction : NSObject</div><div class="line"> </div><div class="line">@property (nonatomic) NSString* payee;   // To whom</div><div class="line">@property (nonatomic) NSNumber* amount;  // How much</div><div class="line">@property (nonatomic) NSDate* date;      // When</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>For the sake of discussion, assume your <code>BankAccount</code> instance has a transactions array populated with the data shown in Table 4-1, and that you make the example calls from inside the <code>BankAccount</code> object.</p>
<p>为了讨论方便，假设你的 <code>BankAccount</code> 实例有交易信息数组，如表4-1，并且该 <code>BankAccount</code> 对象中有示例中的交易信息。</p>
<table>
<thead>
<tr>
<th><code>payee</code> values</th>
<th><code>amount</code> values formatted as currency</th>
<th><code>date</code> values formatted as month day, year</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Green Power</code></td>
<td><code>$120.00</code></td>
<td><code>Dec 1, 2015</code></td>
</tr>
<tr>
<td><code>Green Power</code></td>
<td><code>$150.00</code></td>
<td><code>Jan 1, 2016</code></td>
</tr>
<tr>
<td><code>Green Power</code></td>
<td><code>$170.00</code></td>
<td><code>Feb 1, 2016</code></td>
</tr>
<tr>
<td><code>Car Loan</code></td>
<td><code>$250.00</code></td>
<td><code>Jan 15, 2016</code></td>
</tr>
<tr>
<td><code>Car Loan</code></td>
<td><code>$250.00</code></td>
<td><code>Feb 15, 2016</code></td>
</tr>
<tr>
<td><code>Car Loan</code></td>
<td><code>$250.00</code></td>
<td><code>Mar 15, 2016</code></td>
</tr>
<tr>
<td><code>General Cable</code></td>
<td><code>$120.00</code></td>
<td><code>Dec 1, 2015</code></td>
</tr>
<tr>
<td><code>General Cable</code></td>
<td><code>$155.00</code></td>
<td><code>Jan 1, 2016</code></td>
</tr>
<tr>
<td><code>General Cable</code></td>
<td><code>$120.00</code></td>
<td><code>Feb 1, 2016</code></td>
</tr>
<tr>
<td><code>Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Jan 15, 2016</code></td>
</tr>
<tr>
<td><code>Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Feb 15, 2016</code></td>
</tr>
<tr>
<td><code>Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Mar 15, 2016</code></td>
</tr>
<tr>
<td><code>Animal Hospital</code></td>
<td><code>$600.00</code></td>
<td><code>Jul 15, 2016</code></td>
</tr>
</tbody>
</table>
<h3 id="Aggregation-Operators"><a href="#Aggregation-Operators" class="headerlink" title="Aggregation Operators"></a>Aggregation Operators</h3><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Aggregation operators work on either an array or set of properties, producing a single value that reflects some aspect of the collection.</p>
<p>聚合操作对数组或者集合对象进行操作，并提供一个反应该容器对象某个方面的值。</p>
<h4 id="avg"><a href="#avg" class="headerlink" title="@avg"></a>@avg</h4><p>When you specify the <code>@avg</code> operator, <code>valueForKeyPath:</code> reads the property specified by the right key path for each element of the collection, converts it to a <code>double</code> (substituting 0 for <code>nil</code> values), and computes the arithmetic average of these. It then returns the result stored in an <code>NSNumber</code> instance.</p>
<p>当你指定 <code>@avg</code> 操作符， <code>valueForKeyPath:</code> 会根据右边的关键路径读取集合中的每一项的该属性，并将其转化为 <code>double</code>（<code>nil</code> 则会使用 0 代替），然后计算所有属性值的算术平均值。最后将结果存储在一个 <code>NSNumber</code> 实例中并返回。</p>
<p>To obtain the average transaction amount among the sample data in Table 4-1:</p>
<p>要获取表 4-1 中样本数据的平均交易金额：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;];</div></pre></td></tr></table></figure>
<p>The formatted result of <code>transactionAverage</code> is $456.54.</p>
<p><code>transactionAverage</code> 的格式化结果是 $456.54。</p>
<h4 id="count"><a href="#count" class="headerlink" title="@count"></a>@count</h4><p>When you specify the <code>@count</code> operator, <code>valueForKeyPath:</code> returns the number of objects in the collection in an <code>NSNumber</code> instance. The right key path, if present, is ignored.</p>
<p>当你指定 <code>@count</code> 操作符， <code>valueForKeyPath:</code> 会返回包含着集合中对象数量的 <code>NSNumber</code> 对象。如果有右边的关键路径也会被忽略。</p>
<p>To obtain the number of <code>Transaction</code> objects in <code>transactions</code>:</p>
<p>要获取表 4-1 中 <code>transactions</code> 容器中的 <code>Transaction</code> 对象数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;];</div></pre></td></tr></table></figure>
<p>The value of <code>numberOfTransactions</code> is 13.</p>
<p><code>numberOfTransactions</code> 的值是 13。</p>
<h4 id="max"><a href="#max" class="headerlink" title="@max"></a>@max</h4><p>When you specify the <code>@max</code> operator, <code>valueForKeyPath:</code> searches among the collection entries named by the right key path and returns the largest one. The search conducts comparisons using the <code>compare:</code> method, as defined by many Foundation classes, such as the <code>NSNumber</code> class. Therefore, the property indicated by the right key path must hold an object that responds meaningfully to this message. The search ignores <code>nil</code> valued collection entries.</p>
<p>当你指定 <code>@max</code> 操作符， <code>valueForKeyPath:</code> 会根据右边关键路径的名字搜索容器中的每一项并返回最大的那个。搜索使用许多 Foundation 类中都有定义的 <code>compare</code> 方法进行比较，比如 <code>NSNumber</code> 类。因此，右边关键路径所指示的对象对该消息的响应必须有意义。搜索会忽略集合中的 <code>nil</code> 值。</p>
<p>To obtain the maximum of the date values, which is the date of the latest transaction, among the transactions listed in Table 4-1:</p>
<p>要获取表 4-1 中最大的日期值，即交易中最近的日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;];</div></pre></td></tr></table></figure>
<p>The formatted <code>latestDate</code> value is Jul 15, 2016.</p>
<p><code>latestDate</code> 格式化后的值是 2016年7月15日。</p>
<h4 id="min"><a href="#min" class="headerlink" title="@min"></a>@min</h4><p>When you specify the <code>@min</code> operator, <code>valueForKeyPath:</code> searches among the collection entries named by the right key path and returns the smallest one. The search conducts comparisons using the <code>compare:</code> method, as defined by many Foundation classes, such as the <code>NSNumber</code> class. Therefore, the property indicated by the right key path must hold an object that responds meaningfully to this message. The search ignores <code>nil</code> valued collection entries.</p>
<p>当你指定 <code>@min</code> 操作符， <code>valueForKeyPath:</code> 会根据右边关键路径的名字搜索容器中的每一项并返回最小的那个。搜索使用许多 Foundation 类中都有定义的 <code>compare</code> 方法进行比较，比如 <code>NSNumber</code> 类。因此，右边关键路径所指示的对象对该消息的响应必须有意义。搜索会忽略集合中的 <code>nil</code> 值。</p>
<p>To obtain the minimum of the date values, which is the date of the earliest transaction, among the transactions listed in Table 4-1:</p>
<p>要获取表 4-1 中最小的日期值，即交易中最早的日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSDate *earliestDate = [self.transactions valueForKeyPath:@&quot;@min.date&quot;];</div></pre></td></tr></table></figure>
<p>The formatted <code>earliestDate</code> value is Dec 1, 2015.</p>
<p><code>earliestDate</code> 格式化后的值是 2015年12月1日。</p>
<h4 id="sum"><a href="#sum" class="headerlink" title="@sum"></a>@sum</h4><p>When you specify the <code>@sum</code> operator, <code>valueForKeyPath:</code> reads the property specified by the right key path for each element of the collection, converts it to a <code>double</code> (substituting 0 for <code>nil</code> values), and computes the sum of these. It then returns the result stored in an <code>NSNumber</code> instance.</p>
<p>当你指定 <code>@sum</code> 操作符， <code>valueForKeyPath:</code> 会根据右边的关键路径读取集合中的每一项的该属性，并将其转化为 <code>double</code>（<code>nil</code> 则会使用 0 代替），然后计算所有属性值的和。最后将结果存储在一个 <code>NSNumber</code> 实例中并返回。</p>
<p>To obtain the sum of the transactions amount among the sample data in Table 4-1:</p>
<p>要获取表 4-1 中样本数据的平均交易的总和：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *amountSum = [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;];</div></pre></td></tr></table></figure>
<p>The formatted result of <code>amountSum</code> is $5,935.00.</p>
<p><code>amountSum</code> 格式化后的结果是 $5,935.00。</p>
<h3 id="Array-Operators"><a href="#Array-Operators" class="headerlink" title="Array Operators"></a>Array Operators</h3><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>The array operators cause <code>valueForKeyPath:</code> to return an array of objects corresponding to a particular set of the objects indicated by the right key path.</p>
<p> 数组运算符使 <code>valueForKeyPath:</code> 返回与右边关键路径指定的特定对象数组。</p>
<blockquote>
<p>IMPORTANT</p>
<p>The <code>valueForKeyPath:</code> method raises an exception if any of the leaf objects is <code>nil</code> when using array operators.</p>
<p>重要</p>
<p>只要任何一个叶子对象在使用数组操作时为 <code>nil</code>，则  <code>valueForKeyPath:</code> 方法会抛出异常。</p>
</blockquote>
<h4 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h4><p>When you specify the <code>@distinctUnionOfObjects</code> operator, <code>valueForKeyPath:</code> creates and returns an array containing the distinct objects of the collection corresponding to the property specified by the right key path.</p>
<p>当你指定 <code>@distinctUnionOfObjects</code> 操作符，<code>valueForKeyPath:</code> 会根据右边关键路径创建并返回一个包含原容器中所有对象指定属性的不同值的数组。</p>
<p>To obtain a collection of <code>payee</code> property values for the transactions in <code>transactions</code> with duplicate values omitted:</p>
<p>要获取一个包含 <code>transactions</code> 数组中所有不同 <code>payee</code> 属性值的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *distinctPayees = [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;];</div></pre></td></tr></table></figure>
<p>The resulting <code>distinctPayees</code> array contains one instance each of the following strings: Car Loan, General Cable, Animal Hospital, Green Power, Mortgage.</p>
<p>返回的 <code>distinctPayees</code> 数组中包含如下字符串：Car Loan, General Cable, Animal Hospital, Green Power, Mortgage。</p>
<blockquote>
<p>NOTE</p>
<p>The <code>@unionOfObjects</code> operator provides similar behavior, but without removing duplicate objects.</p>
<p>注意</p>
<p><code>@unionOfObjects</code> 操作符与之类似，但是不会移除重复的对象。</p>
</blockquote>
<h4 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h4><p>When you specify the <code>@unionOfObjects</code> operator, <code>valueForKeyPath:</code> creates and returns an array containing all the objects of the collection corresponding to property specified by the right key path. Unlike @distinctUnionOfObjects, duplicate objects are not removed.</p>
<p>当你指定 <code>@unionOfObjects</code> 操作符，<code>valueForKeyPath:</code> 会根据右边关键路径创建并返回一个包含原容器中所有对象指定属性的值的数组。不同于 @distinctUnionOfObjects ，重复的对象并不会移除。</p>
<p>To obtain a collection of <code>payee</code> property values for the transactions in <code>transactions</code>:</p>
<p>要获取一个包含 <code>transactions</code> 数组中所有 <code>payee</code> 属性值的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *payees = [self.transactions valueForKeyPath:@&quot;@unionOfObjects.payee&quot;];</div></pre></td></tr></table></figure>
<p>The resulting <code>payees</code> array contains the following strings: Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital. Note the duplicates.</p>
<p>返回的 payees`` 数组中包含如下字符串：Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital。注意这其中的重复项。</p>
<blockquote>
<p>NOTE</p>
<p>The <code>@distinctUnionOfArrays</code> operator is similar, but removes duplicate objects.</p>
<p>注意</p>
<p><code>@distinctUnionOfArrays</code> 操作符与之类似，但是会移除重复的对象。</p>
</blockquote>
<h3 id="Nesting-Operators"><a href="#Nesting-Operators" class="headerlink" title="Nesting Operators"></a>Nesting Operators</h3><h3 id="嵌套操作"><a href="#嵌套操作" class="headerlink" title="嵌套操作"></a>嵌套操作</h3><p>The nesting operators operate on nested collections, where each entry of the collection itself contains a collection.</p>
<p>嵌套操作是用来操作嵌套集合的，嵌套集合内部包含的实体都是集合。</p>
<blockquote>
<p>IMPORTANT</p>
<p>The <code>valueForKeyPath:</code> method raises an exception if any of the leaf objects is <code>nil</code> when using nesting operators.</p>
<p>重要</p>
<p><code>valueForKeyPath:</code> 在使用嵌套操作时，如果有子节点对象为 <code>nil</code>，则会抛出异常。</p>
</blockquote>
<p>For the descriptions that follow, consider a second array of data called <code>moreTransactions</code>, populated with the data in Table 4-2, and collected together with the original <code>transactions</code> array (from the <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW3" target="_blank" rel="external">Sample Data</a> section) into a nested array:</p>
<p>在下述描述中，考虑第二个名字为 <code>moreTransactions</code>  的数组，使用的是表4-2中的数据进行填充，并且和原先的 <code>transactions</code> 放在了同一个数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray* moreTransactions = @[&lt;# transaction data #&gt;];</div><div class="line">NSArray* arrayOfArrays = @[self.transactions, moreTransactions];</div></pre></td></tr></table></figure>
<p>Table 4-2 Hypothetical Transaction data in the moreTransactions array</p>
<table>
<thead>
<tr>
<th><code>payee</code> values</th>
<th><code>amount</code> values formatted as currency</th>
<th><code>date</code> values formatted as month day, year</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>General Cable - Cottage</code></td>
<td><code>$120.00</code></td>
<td><code>Dec 18, 2015</code></td>
</tr>
<tr>
<td><code>General Cable - Cottage</code></td>
<td><code>$155.00</code></td>
<td><code>Jan 9, 2016</code></td>
</tr>
<tr>
<td><code>General Cable - Cottage</code></td>
<td><code>$120.00</code></td>
<td><code>Dec 1, 2016</code></td>
</tr>
<tr>
<td><code>Second Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Nov 15, 2016</code></td>
</tr>
<tr>
<td><code>Second Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Sep 20, 2016</code></td>
</tr>
<tr>
<td><code>Second Mortgage</code></td>
<td><code>$1,250.00</code></td>
<td><code>Feb 12, 2016</code></td>
</tr>
<tr>
<td><code>Hobby Shop</code></td>
<td><code>$600.00</code></td>
<td><code>Jun 14, 2016</code></td>
</tr>
</tbody>
</table>
<h4 id="distinctUnionOfArrays"><a href="#distinctUnionOfArrays" class="headerlink" title="@distinctUnionOfArrays"></a>@distinctUnionOfArrays</h4><p>When you specify the <code>@distinctUnionOfArrays</code> operator, <code>valueForKeyPath:</code> creates and returns an array containing the distinct objects of the combination of all the collections corresponding to the property specified by the right key path.</p>
<p>当你指定 <code>@distinctUnionOfArrays</code> 操作符，<code>valueForKeyPath:</code> 会根据右边关键路径创建并返回一个包含所有容器中所有对象指定属性的不同值的数组。</p>
<p>To obtain the distinct values of the <code>payee</code> property among all the arrays in <code>arrayOfArrays</code>:</p>
<p>要获取一个包含 <code>arrayOfArrays</code> 中所有数组里不同 <code>payee</code> 属性值的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;];</div></pre></td></tr></table></figure>
<p>The resulting <code>collectedDistinctPayees</code> array contains the following values: Hobby Shop, Mortgage, Animal Hospital, Second Mortgage, Car Loan, General Cable - Cottage, General Cable, Green Power.</p>
<p>结果中的 <code>collectedDistinctPayees</code> 数组包含以下的值：Hobby Shop, Mortgage, Animal Hospital, Second Mortgage, Car Loan, General Cable - Cottage, General Cable, Green Power。</p>
<blockquote>
<p>NOTE</p>
<p>The <code>@unionOfArrays</code> operator is similar, but does not remove duplicate objects.</p>
<p>注意</p>
<p> <code>@unionOfArrays</code> 操作符与之类似，但是不会移除重复的对象。</p>
</blockquote>
<h4 id="unionOfArrays"><a href="#unionOfArrays" class="headerlink" title="@unionOfArrays"></a>@unionOfArrays</h4><p>When you specify the <code>@unionOfArrays</code> operator, <code>valueForKeyPath:</code> creates and returns an array containing the all the objects of the combination of all the collections corresponding to the property specified by the right key path, without removing duplicates.</p>
<p>当你指定 <code>@distinctUnionOfArrays</code> 操作符，<code>valueForKeyPath:</code> 会根据右边关键路径创建并返回一个数组，该数组包含所有容器中所有对象指定属性的值，并且不删除重复的值。</p>
<p>To obtain the values of the <code>payee</code> property in all the arrays within <code>arrayOfArrays</code>:</p>
<p>要获取一个包含 <code>arrayOfArrays</code> 中所有数组里 <code>payee</code> 属性值的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *collectedPayees = [arrayOfArrays valueForKeyPath:@&quot;@unionOfArrays.payee&quot;];</div></pre></td></tr></table></figure>
<p>The resulting <code>collectedPayees</code> array contains the following values: Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital, General Cable - Cottage, General Cable - Cottage, General Cable - Cottage, Second Mortgage, Second Mortgage, Second Mortgage, Hobby Shop.</p>
<p>结果中的 <code>collectedPayees</code> 数组包含以下的值：Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital, General Cable - Cottage, General Cable - Cottage, General Cable - Cottage, Second Mortgage, Second Mortgage, Second Mortgage, Hobby Shop。</p>
<blockquote>
<p>NOTE</p>
<p>The <code>@distinctUnionOfArrays</code> operator is similar, but removes duplicate objects.</p>
<p>注意</p>
<p> <code>@distinctUnionOfArrays</code> 操作符与之类似，但是会移除重复的对象。</p>
</blockquote>
<h4 id="distinctUnionOfSets"><a href="#distinctUnionOfSets" class="headerlink" title="@distinctUnionOfSets"></a>@distinctUnionOfSets</h4><p>When you specify the <code>@distinctUnionOfSets</code> operator, <code>valueForKeyPath:</code> creates and returns an <code>NSSet</code>object containing the distinct objects of the combination of all the collections corresponding to the property specified by the right key path.</p>
<p>当你指定 <code>@distinctUnionOfSets</code> 操作符，<code>valueForKeyPath:</code> 会根据右边关键路径创建并返回一个 <code>NSSet</code> ，该对象包含所有容器中所有对象指定属性的不同的值。</p>
<p>This operator behaves just like <code>@distinctUnionOfArrays</code>, except that it expects an <code>NSSet</code> instance containing <code>NSSet</code> instances of objects rather than an <code>NSArray</code> instance of <code>NSArray</code> instances. Also, it returns an <code>NSSet</code>instance. Assuming the example data had been stored in sets instead of arrays, the example call and results are the same as those shown for <code>@distinctUnionOfArrays</code>.</p>
<p>该操作符和 <code>@distinctUnionOfArrays</code> 类似，除了作用对象是嵌套的 <code>NSSet</code> 对象。因此返回值也是一个 <code>NSSet</code> 对象。假设例子中的数据都存在于 set 中，那么例子中的调用结果和 <code>@distinctUnionOfArrays</code> 一致。</p>
<h2 id="Representing-Non-Object-Values"><a href="#Representing-Non-Object-Values" class="headerlink" title="Representing Non-Object Values"></a>Representing Non-Object Values</h2><h2 id="表示非对象值"><a href="#表示非对象值" class="headerlink" title="表示非对象值"></a>表示非对象值</h2><p>The default implementation of the key-value coding protocol methods provided by <code>NSObject</code> work with both object and non-object properties. The default implementation automatically translates between object parameters or return values, and non-object properties. This allows the signatures of the key-based getters and setters to remain consistent even when the stored property is a scalar or a structure.</p>
<p><code>NSObject</code> 对象对于 KVC 的默认实现对于 对象或者非对象属性都是适用的。默认实现会在对象参数、返回值以及非对象属性之间自动转换。这允许关键的 getter 和 setter 方法的签名保持一致，及时属性是个基本数据类型或者结构体。</p>
<blockquote>
<p>NOTE</p>
<p>Because all properties in Swift are objects, this section only apples to Objective-C properties.</p>
<p>注意</p>
<p>因为 Swift 中所有属性都是对象，所以这条只应用于 Objective-C 属性。</p>
</blockquote>
<p>When you invoke one of the protocol’s getters, such as <code>valueForKey:</code>, the default implementation determines the particular accessor method or instance variable that supplies the value for the specified key according to the rules described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a>. If the return value is not an object, the getter uses this value to initialize an <code>NSNumber</code> object (for scalars) or <code>NSValue</code> object (for structures) and returns that instead.</p>
<p>当你触发协议中的获取方法是，例如 <code>valueForKey:</code> ，默认实现会根据  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a> 中所描述的规则去查找访问方法或者是实例变量。如果返回值不是一个对象，那么获取方法会使用 <code>NSNumber</code> 或者 <code>NSValue</code> 来包装基本数据类型和结构体来替代（返回）。</p>
<p>Similarly, by default, setters like <code>setValue:forKey:</code> determine the data type required by a property’s accessor or instance variable, given a particular key. If the data type is not an object, the setter first sends an appropriate <code>&lt;type&gt;Value</code> message to the incoming value object to extract the underlying data, and stores that instead.</p>
<p>同样的，在默认实现下，像  <code>setValue:forKey:</code> 这样的 setter 方法会根据特定的键来确定属性访问方法或者实例变量。如果数据类型不是对象，那么 setter 首先会想传入的值发送合适的 <code>&lt;type&gt;Value</code> 消息以提取底层数据，然后代替（传入）。</p>
<blockquote>
<p>NOTE</p>
<p>When you invoke one of the key-value coding protocol setters with a <code>nil</code> value for a non-object property, the setter has no obvious, general course of action to take. Therefore, it sends a <code>setNilValueForKey:</code> message to the object receiving the setter call. The default implementation of this method raises an <code>NSInvalidArgumentException</code> exception, but subclasses may override this behavior, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a>, for example to set a marker value, or provide a meaningful default.</p>
<p>注意</p>
<p>当你使用 KVC 的 setter 方法给非对象属性设置一个 <code>nil</code> 值时，setter 方法不会执行一般的操作过程。因此它会向 setter 方法的接收者发送一个 <code>setNilValueForKey:</code> 消息。该方法的默认实现会抛出一个 <code>NSInvalidArgumentException</code> 异常，但是子类可以重写这个方法，像 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a> 中描述的那样，例如设置一个标记值，或者提供一个有意义的默认值。</p>
</blockquote>
<h3 id="Wrapping-and-Unwrapping-Scalar-Types"><a href="#Wrapping-and-Unwrapping-Scalar-Types" class="headerlink" title="Wrapping and Unwrapping Scalar Types"></a>Wrapping and Unwrapping Scalar Types</h3><h3 id="包装以及拆包基本数据类型"><a href="#包装以及拆包基本数据类型" class="headerlink" title="包装以及拆包基本数据类型"></a>包装以及拆包基本数据类型</h3><p>Table 5-1 lists the scalar types that the default key-value coding implementation wraps using an <code>NSNumber</code>instance. For each data type, the table shows the creation method used to initialize an <code>NSNumber</code> from the underlying property value to supply a getter return value. It then shows the accessor method used to extract the value from the setter input parameter during a set operation.</p>
<p>表5-1 列举了 KVC 中默认使用 <code>NSNumber</code> 来包装的基本数据类型。表格中展示了每一种数据类型初始化为 <code>NSNumber</code> 对象的方法以作为返回值。它也展示了在 setter 操作方法时从参数中提取基本数据类型的方法。</p>
<p><strong>Table 5-1</strong>Scalar types as wrapped in <code>NSNumber</code> objects</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Creation method</th>
<th>Accessor method</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BOOL</code></td>
<td><code>numberWithBool:</code></td>
<td><code>boolValue</code> (in iOS)<code>charValue</code> (in macOS)*</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>numberWithChar:</code></td>
<td><code>charValue</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>numberWithDouble:</code></td>
<td><code>doubleValue</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>numberWithFloat:</code></td>
<td><code>floatValue</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>numberWithInt:</code></td>
<td><code>intValue</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>numberWithLong:</code></td>
<td><code>longValue</code></td>
</tr>
<tr>
<td><code>long long</code></td>
<td><code>numberWithLongLong:</code></td>
<td><code>longLongValue</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>numberWithShort:</code></td>
<td><code>shortValue</code></td>
</tr>
<tr>
<td><code>unsigned char</code></td>
<td><code>numberWithUnsignedChar:</code></td>
<td><code>unsignedChar</code></td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td><code>numberWithUnsignedInt:</code></td>
<td><code>unsignedInt</code></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>numberWithUnsignedLong:</code></td>
<td><code>unsignedLong</code></td>
</tr>
<tr>
<td><code>unsigned long long</code></td>
<td><code>numberWithUnsignedLongLong:</code></td>
<td><code>unsignedLongLong</code></td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td><code>numberWithUnsignedShort:</code></td>
<td><code>unsignedShort</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>NOTE</p>
<p>*In macOS, for historical reasons, <code>BOOL</code> is type defined as <code>signed char</code>, and KVC does not distinguish between these. As a result, you should not pass a string value such as <code>@“true”</code> or <code>@“YES”</code> to <code>setValue:forKey:</code> when the key is a <code>BOOL</code>. KVC will attempt to invoke <code>charValue</code> (because the <code>BOOL</code> is inherently a <code>char</code>), but <code>NSString</code> does not implement this method, which results in a runtime error. Instead, pass only an <code>NSNumber</code> object, such as <code>@(1)</code> or <code>@(YES)</code>, as the value argument to <code>setValue:forKey:</code>when the key is a <code>BOOL</code>. This restriction does not apply in iOS, where <code>BOOL</code> is type defined as the native Boolean type <code>bool</code> and KVC invokes <code>boolValue</code>, which works for either an <code>NSNumber</code> object or a properly formatted <code>NSString</code> object.</p>
<p>注意</p>
<p>在 macOS 中，由于历史原因，<code>BOOL</code> 定义为 <code>signed char</code> 类型，但是 KVC 并不区分这些。因此，当 <code>setValue:forKey:</code> 方法中的 key 是 <code>BOOL</code> 类型是，你不应该传入类似于 <code>@&quot;true&quot;</code> 或者 <code>@&quot;YES&quot;</code> 等的字符串。KVC 会尝试调用 <code>charValue</code> （因为 <code>BOOL</code> 的本质是 <code>char</code>），但是 <code>NSString</code> 并没有实现该方法，因此运行时系统会产生错误。因此当 <code>setValue:forKey:</code> 的 key 是 <code>BOOL</code> 类型时，只能传入 <code>NSNumber</code> 对象，比如 <code>@(1)</code> 或者 <code>@(YES)</code>。该限制不适用于 iOS，在 iOS 中 <code>BOOL</code> 是 原生的 <code>bool</code> 类型，因此 KVC 会调用 <code>boolValue</code> 方法，该方法在 <code>NSNumber</code> 和 <code>NSString</code> 对象中都能够调用。</p>
</blockquote>
<h3 id="Wrapping-and-Unwrapping-Structures"><a href="#Wrapping-and-Unwrapping-Structures" class="headerlink" title="Wrapping and Unwrapping Structures"></a>Wrapping and Unwrapping Structures</h3><h3 id="包装以及拆包结构体"><a href="#包装以及拆包结构体" class="headerlink" title="包装以及拆包结构体"></a>包装以及拆包结构体</h3><p>Table 5-2 shows the creation and accessor methods that the default accessors use for wrapping and unwrapping the common <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, and <code>NSSize</code> structures.</p>
<p>表 5-2 展示了用来包装以及拆包  <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, 和 <code>NSSize</code> 结构体的创建以及访问方法。</p>
<p>Table 5-2 Common struct types as wrapped using <code>NSValue</code>.</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Creation method</th>
<th>Accessor method</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NSPoint</code></td>
<td><code>valueWithPoint:</code></td>
<td><code>pointValue</code></td>
</tr>
<tr>
<td><code>NSRange</code></td>
<td><code>valueWithRange:</code></td>
<td><code>rangeValue</code></td>
</tr>
<tr>
<td><code>NSRect</code></td>
<td><code>valueWithRect:</code> (macOS only).</td>
<td><code>rectValue</code></td>
</tr>
<tr>
<td><code>NSSize</code></td>
<td><code>valueWithSize:</code></td>
<td><code>sizeValue</code></td>
</tr>
</tbody>
</table>
<p>Automatic wrapping and unwrapping is not confined to <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, and <code>NSSize</code>. Structure types (that is, types whose Objective-C type encoding strings start with <code>{</code>) can be wrapped in an <code>NSValue</code> object. For example, consider the structure and class interface declared in Listing 5-1.</p>
<p>自动包装以及拆包不仅仅受限于 <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, 以及 <code>NSSize</code> 中。结构体都能都被包装成 <code>NSValue</code> 类型。例如，考虑 5-1 列表中声明的结构体和类接口。</p>
<p><strong>Listing 5-1 </strong>A sample class using a custom structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    float x, y, z;</div><div class="line">&#125; ThreeFloats;</div><div class="line"> </div><div class="line">@interface MyClass</div><div class="line">@property (nonatomic) ThreeFloats threeFloats;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Using an instance of this class called <code>myClass</code>, you obtain the <code>threeFloats</code> value with key-value coding:</p>
<p>使用上述类的一个 <code>myClass</code> 对象，你可以通过 KVC 获取 <code>threeFloats</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSValue* result = [myClass valueForKey:@&quot;threeFloats&quot;];</div></pre></td></tr></table></figure>
<p>The default implementation of <code>valueForKey:</code> invokes the <code>threeFloats</code> getter, and then returns the result wrapped in an <code>NSValue</code> object.</p>
<p><code>valueForKey:</code> 的默认实现会调用 <code>threeFloats</code> 的 getter 方法，然后将值包装成一个 <code>NSValue</code> 对象来返回。</p>
<p>Similarly, you can set the <code>threeFloats</code> value using key-value coding:</p>
<p>类似的，你可以使用 KVC 来 set <code>threeFloats</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ThreeFloats floats = &#123;1., 2., 3.&#125;;</div><div class="line">NSValue* value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</div><div class="line">[myClass setValue:value forKey:@&quot;threeFloats&quot;];</div></pre></td></tr></table></figure>
<p>The default implementation unwraps the value with a <code>getValue:</code> message, and then invokes <code>setThreeFloats:</code>with the resulting structure.</p>
<p>默认实现里会使用 <code>getValue:</code> 方法对消息参数进行拆包，然后调用 <code>setThreeFloats:</code> 方法。</p>
<h2 id="Validating-Properties"><a href="#Validating-Properties" class="headerlink" title="Validating Properties"></a>Validating Properties</h2><h2 id="验证属性"><a href="#验证属性" class="headerlink" title="验证属性"></a>验证属性</h2><p>The key-value coding protocol defines methods to support property validation. Just as you use key-based accessors to read and write properties of a key-value coding compliant object, you can also validate properties by key (or key path). When you call the <code>validateValue:forKey:error:</code> (or the <code>validateValue:forKeyPath:error:</code>) method, the default implementation of the protocol searches the object receiving the validation message (or the one at the end of the key path) for a method whose name matches the pattern <code>validate&lt;Key&gt;:error:</code>. If the object has no such method, the validation succeeds by default, and the default implementation returns <code>YES</code>. When a property-specific validation method exists, the default implementation returns the result of calling that method instead.</p>
<p>KVC 协议中定义了支持属性验证的方法。就像你使用基于键去读取以及写入属性一样，你也可以使用键（或键路径）来验证属性。当你调用 <code>validateValue:forKey:error:</code> （或者 <code>validateValue:forKeyPath:error:</code>）方法，协议的默认实现会从消息接收对象中根据键（—或者键路径中的一部分）查找命名为 <code>validate&lt;Key&gt;:error:</code> 的方法。如果该对象没有这些方法，那么默认会验证成功，默认实现里会返回 <code>YES</code>。当该属性的验证方法存在，那么会返回调用该方法的结果。</p>
<blockquote>
<p>NOTE</p>
<p>You typically use the validation described here only in Objective-C. In Swift, property validation is more idiomatically handled by relying on compiler support for optionals and strong type checking, while using the built-in <code>willSet</code> and <code>didSet</code> property observers to test any run-time API contracts, as described in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262" target="_blank" rel="external">Property Observers</a> section of <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a>.</p>
<p>注意</p>
<p>你通常只能在 Objective-C 中使用属性验证。在 Swift 中，属性验证通常依赖编译器支持的可选项和强类型检查，同时使用内置的 <code>willSet</code> 和 <code>didSet</code> 属性观察器来测试运行时的 API 约定，就像 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a> 中的 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262" target="_blank" rel="external">Property Observers</a>  章节描述的那样。</p>
</blockquote>
<p>Because property-specific validation methods receive the value and error parameters by reference, validation has three possible outcomes:</p>
<p>因为由属性指定的验证方法会收到参数里的属性值和错误对象的引用，因此验证可能有三种可能的结果：</p>
<ol>
<li><p>The validation method deems the value object valid and returns <code>YES</code> without altering the value or the error.</p>
<p>验证方法认为值是有效的，不改变值或者 error 的情况下返回 <code>YES</code>。</p>
</li>
<li><p>The validation method deems the value object invalid, but chooses not to alter it. In this case, the method returns <code>NO</code> and sets the error reference (if provided by the caller) to an <code>NSError</code> object that indicates the reason for failure.</p>
<p>验证方法认为值是无效的，但是不改变该值。在这种情况下，该方法返回 <code>NO</code> 并将传入的 error 设置一个用来指示失败原因的 <code>NSError</code> 对象。</p>
</li>
<li><p>The validation method deems the value object invalid, but creates a new, valid one as a replacement. In this case, the method returns <code>YES</code> while leaving the error object untouched. Before returning, the method modifies the value reference to point at the new value object. When it makes a modification, the method always creates a new object, rather than modifying the old one, even if the value object is mutable.</p>
<p>验证方法认为值是无效的，但是会创建一个新的有效的值来代替传入的值。在这种情况下，该方法会返回 <code>YES</code> 同时保持 error 不变。在返回之前，该方法会将值指向一个新的值。当它进行修改时，该方法总是会创建一个新的对象，而不是修改旧对象，即使旧对象是可变的。</p>
</li>
</ol>
<p>Listing 6-1 shows an example of how to call validation for a name string.</p>
<p>6-1 清单展示了如何调用验证方法验证 name 字符串：</p>
<p><strong>Listing 6-1 </strong>Validation of the name property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Person* person = [[Person alloc] init];</div><div class="line">NSError* error;</div><div class="line">NSString* name = @&quot;John&quot;;</div><div class="line">if (![person validateValue:&amp;name forKey:@&quot;name&quot; error:&amp;error]) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Automatic-Validation"><a href="#Automatic-Validation" class="headerlink" title="Automatic Validation"></a>Automatic Validation</h3><h3 id="自动验证"><a href="#自动验证" class="headerlink" title="自动验证"></a>自动验证</h3><p>In general, neither the key-value coding protocol nor its default implementation define any mechanism to perform validation automatically. Instead, you make use of the validation methods when appropriate for your app.</p>
<p>通常，KVC 及其默认实现都不定义任何自动执行验证的机制。相反的，你会在合适的实际调用验证方法。</p>
<p>Certain other Cocoa technologies do perform validation automatically in some circumstances. For example, Core Data automatically performs validation when the managed object context is saved (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external"><em>Core Data Programming Guide</em></a>). Also, in macOS, Cocoa bindings allow you to specify that validation should occur automatically (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i" target="_blank" rel="external"><em>Cocoa Bindings Programming Topics</em></a> for more information).</p>
<p>在某些情况下，其他 Cocoa 技术会自动执行验证。例如， Core Data 会在 managed object context 存储是自动进行验证（参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="external"><em>Core Data Programming Guide</em></a>）。在 macOS 中， Cocoa 绑定技术允许你指定是否应该自动验证（参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i" target="_blank" rel="external"><em>Cocoa Bindings Programming Topics</em></a> ）。</p>
<h2 id="Accessor-Search-Patterns"><a href="#Accessor-Search-Patterns" class="headerlink" title="Accessor Search Patterns"></a>Accessor Search Patterns</h2><h2 id="访问器搜索模式"><a href="#访问器搜索模式" class="headerlink" title="访问器搜索模式"></a>访问器搜索模式</h2><p>The default implementation of the <code>NSKeyValueCoding</code> protocol provided by <code>NSObject</code> maps key-based accessor calls to an object’s underlying properties using a clearly defined set of rules. These protocol methods use a key parameter to search their own object instance for accessors, instance variables, and related methods that follow certain naming conventions. Although you rarely modify this default search, it can be helpful to understand how it works, both for tracing the behavior of key-value coded objects, and for making your own objects compliant.</p>
<p>由 <code>NSObject</code> 默认实现的 KVC 协议方法里通过明确的规则来映射访问方法以及底层的属性。这些协议的方法通过遵守某些命名约定使用关键参数来查找他们的访问方法，实例变量以及相关的方法。尽管你很少会去修改搜索的默认实现，但是这对于你理解 KVC 的实现还是很有帮助的，即可以用于跟踪 KVC 对象的行为，也可以用来兼容你自己的对象。</p>
<blockquote>
<p>NOTE</p>
<p>The descriptions in this section use <code>&lt;key&gt;</code> or <code>&lt;Key&gt;</code> as a placeholder for the key string that appears as a parameter in one of the key-value coding protocol methods, which is then used by that method as part of a secondary method call or variable name lookup. The mapped property name obeys the placeholder’s case. For example, for the getters <code>&lt;key&gt;</code> and <code>is&lt;Key&gt;</code>, the property named hidden maps to <code>hidden</code> and <code>isHidden</code>.</p>
<p>注意</p>
<p>本节中的描述使用 <code>&lt;key&gt;</code> 或 <code>&lt;Key&gt;</code> 作为键字符串的占位符，该键字符串作为一个 KVC 协议方法中的一个参数出现，然后该方法作为第二个方法调用或变量名查找的一部分使用。映射的属性名遵从占位符。例如，getters 方法里的 <code>&lt;key&gt;</code> 和 <code>&lt;is&lt;Key&gt;&gt;</code>，hidden 属性映射为 <code>hidden</code> 和 <code>isHidden</code>。</p>
</blockquote>
<h3 id="Search-Pattern-for-the-Basic-Getter"><a href="#Search-Pattern-for-the-Basic-Getter" class="headerlink" title="Search Pattern for the Basic Getter"></a>Search Pattern for the Basic Getter</h3><h3 id="获取方法的搜索模式"><a href="#获取方法的搜索模式" class="headerlink" title="获取方法的搜索模式"></a>获取方法的搜索模式</h3><p>The default implementation of <code>valueForKey:</code>, given a <code>key</code> parameter as input, carries out the following procedure, operating from within the class instance receiving the <code>valueForKey:</code> call.</p>
<p>给定一个 <code>key</code> 参数 作为 <code>valueForKey:</code>  方法的输入，在实例中的默认实现会执行以下过程。</p>
<ol>
<li><p>Search the instance for the first accessor method found with a name like <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, or <code>_&lt;key&gt;</code>, in that order. If found, invoke it and proceed to step 5 with the result. Otherwise proceed to the next step.</p>
<p>按照 <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, 或 <code>_&lt;key&gt;</code> 的顺序搜索实例以找到第一个访问方法。如果找到了方法，那么会调用该方法得到结果并执行第5步。否则执行下一步。</p>
<p>​</p>
</li>
<li><p>If no simple accessor method is found, search the instance for methods whose names match the patterns <code>countOf&lt;Key&gt;</code> and <code>objectIn&lt;Key&gt;AtIndex:</code> (corresponding to the primitive methods defined by the <code>NSArray</code> class) and <code>&lt;key&gt;AtIndexes:</code> (corresponding to the <code>NSArray</code> method <code>objectsAtIndexes:</code>).</p>
<p>If the first of these and at least one of the other two is found, create a collection proxy object that responds to all <code>NSArray</code> methods and return that. Otherwise, proceed to step 3.</p>
<p>The proxy object subsequently converts any <code>NSArray</code> messages it receives to some combination of <code>countOf&lt;Key&gt;</code>, <code>objectIn&lt;Key&gt;AtIndex:</code>, and <code>&lt;key&gt;AtIndexes:</code> messages to the key-value coding compliant object that created it. If the original object also implements an optional method with a name like <code>get&lt;Key&gt;:range:</code>, the proxy object uses that as well, when appropriate. In effect, the proxy object working together with the key-value coding compliant object allows the underlying property to behave as if it were an <code>NSArray</code>, even if it is not.</p>
<p>如果没有找到简单的访问器方法，会查找匹配  <code>countOf&lt;Key&gt;</code> 和 <code>objectIn&lt;Key&gt;AtIndex:</code> (对应于由 <code>NSArray</code> 定义的原始方法) 以及  <code>&lt;key&gt;AtIndexes:</code> (对应 <code>NSArray</code> 的 <code>objectAtIndexes:</code> 方法)的实例变量。</p>
<p>如果第一个或者其他两个中的至少一个被找到，则会创建一个能够响应所有 <code>NSArray</code> 方法的代理容器对象并返回。否则，继续执行第3步。</p>
<p>代理对象会将随后收到的任何 <code>NSArray</code> 消息转换成 <code>countOf&lt;Key&gt;</code>, <code>objectIn&lt;Key&gt;AtIndex:</code>, 和 <code>&lt;key&gt;AtIndexes:</code> 的消息组合，转发给创建该代理对象的对象。当原始对象也实现了一个名为 <code>get&lt;Key&gt;:range:</code> 的可选方法，那么代理对象会在合适的时机调用该方法。实际上，代理对象与 KVC 对象一起工作，使得底层属性的行为就好像 <code>NSArray</code> 一样，即使它不是。</p>
<p>​</p>
</li>
<li><p>If no simple accessor method or group of array access methods is found, look for a triple of methods named <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, and <code>memberOf&lt;Key&gt;:</code> (corresponding to the primitive methods defined by the <code>NSSet</code> class).</p>
<p>If all three methods are found, create a collection proxy object that responds to all <code>NSSet</code> methods and return that. Otherwise, proceed to step 4.</p>
<p>This proxy object subsequently converts any <code>NSSet</code> message it receives into some combination of <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, and <code>memberOf&lt;Key&gt;:</code> messages to the object that created it. In effect, the proxy object working together with the key-value coding compliant object allows the underlying property to behave as if it were an <code>NSSet</code>, even if it is not.</p>
<p>如果没有简单的访问器方法或者数组访问方法，寻找名为  <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, 以及 <code>memberOf&lt;Key&gt;:</code>（对应 <code>NSSet</code> 类定义的原始方法） 的方法。</p>
<p>如果这三个方法都被找到了，那么会创建一个能够响应 <code>NSSet</code> 所有方法的容器代理对象并返回。否则，继续执行第4步。</p>
<p>代理对象会将随后收到的任何 <code>NSSet</code> 消息转换成 <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, 和 <code>memberOf&lt;key&gt;:</code> 的消息组合，转发给创建该代理对象的对象。实际上，代理对象与 KVC 对象一起工作，使得底层属性的行为就好像 <code>NSSet</code> 一样，即使它不是。</p>
</li>
<li><p>If no simple accessor method or group of collection access methods is found, and if the receiver’s class method <code>accessInstanceVariablesDirectly</code> returns <code>YES</code>, search for an instance variable named <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, or <code>is&lt;Key&gt;</code>, in that order. If found, directly obtain the value of the instance variable and proceed to step 5. Otherwise, proceed to step 6.</p>
<p>如果简单的访问方法和容器方法都没有找到，并且接收者的类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么就会按照  <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 以及 <code>is&lt;Key&gt;</code> 的顺序查找实例变量。如果找到了，直接获取实例变量的值并且继续执行第5步。否则，继续执行第6步。</p>
</li>
<li><p>If the retrieved property value is an object pointer, simply return the result.</p>
<p>If the value is a scalar type supported by <code>NSNumber</code>, store it in an <code>NSNumber</code> instance and return that.</p>
<p>If the result is a scalar type not supported by <code>NSNumber</code>, convert to an <code>NSValue</code> object and return that.</p>
<p>如果检索到的属性值是个对象指针，简单地返回该结果。</p>
<p>如果检索到的值是一个 <code>NSNumber</code> 支持的基本数据类型，那么存储到一个 <code>NSNumber</code> 实例中并返回。</p>
<p>如果检索到的是 <code>NSNumber</code> 不支持的基本数据类型，那么会转化为 <code>NSValue</code> 对象并返回。</p>
</li>
<li><p>If all else fails, invoke <code>valueForUndefinedKey:</code>. This raises an exception by default, but a subclass of <code>NSObject</code> may provide key-specific behavior.</p>
<p>如果以上所有的条件都失败了，那么触发 <code>valueForUndefinedKey:</code> 方法。该方法默认实现会抛出异常，但是 <code>NSObject</code> 的子类可以提供针对指定 key 的行为。<br>​</p>
</li>
</ol>
<h3 id="Search-Pattern-for-the-Basic-Setter"><a href="#Search-Pattern-for-the-Basic-Setter" class="headerlink" title="Search Pattern for the Basic Setter"></a>Search Pattern for the Basic Setter</h3><h3 id="设置方法的搜索模式"><a href="#设置方法的搜索模式" class="headerlink" title="设置方法的搜索模式"></a>设置方法的搜索模式</h3><p>The default implementation of <code>setValue:forKey:</code>, given <code>key</code> and <code>value</code> parameters as input, attempts to set a property named <code>key</code> to <code>value</code> (or, for non-object properties, the unwrapped version of <code>value</code>, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>) inside the object receiving the call, using the following procedure:</p>
<p><code>setValue:forKey:</code> 的默认实现，在给定 <code>key</code> 和 <code>value</code> 参数作为输入时，尝试将名字为 <code>key</code> 的属性设置值为 <code>value</code> （或者对于不是对象类型的属性，会根据  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 中描述的那样将 <code>value</code> 拆包），在接收者内部会执行以下流程：</p>
<ol>
<li><p>Look for the first accessor named <code>set&lt;Key&gt;:</code> or <code>_set&lt;Key&gt;</code>, in that order. If found, invoke it with the input value (or unwrapped value, as needed) and finish.</p>
<p>按照 <code>set&lt;Key&gt;:</code> 和 <code>_set&lt;Key&gt;</code> 顺序查找访问方法。如果找到了那么使用输入的值（或者根据需要拆包后的值）调用该方法然后结束流程。</p>
</li>
<li><p>If no simple accessor is found, and if the class method <code>accessInstanceVariablesDirectly</code> returns <code>YES</code>, look for an instance variable with a name like <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, or <code>is&lt;Key&gt;</code>, in that order. If found, set the variable directly with the input value (or unwrapped value) and finish.</p>
<p>若果简单的访问方法没有找到，但是类方法 <code>accessInstanceVariablesDirectly</code> 的返回值是 <code>YES</code>，根据 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 以及 <code>is&lt;Key&gt;</code> 的顺序查找实例变量。如果找到了，使用传入的值直接赋值该变量并结束流程。</p>
</li>
<li><p>Upon finding no accessor or instance variable, invoke <code>setValue:forUndefinedKey:</code>. This raises an exception by default, but a subclass of <code>NSObject</code> may provide key-specific behavior.</p>
<p>如果以上的流程都没有找到访问方法或者实例变量，那么会调用 <code>setValue:forUndefinedKey:</code> 方法。该方法默认会抛出异常，但是 <code>NSObject</code> 的子类可以提供针对指定 key 的行为。</p>
</li>
</ol>
<h3 id="Search-Pattern-for-Mutable-Arrays"><a href="#Search-Pattern-for-Mutable-Arrays" class="headerlink" title="Search Pattern for Mutable Arrays"></a>Search Pattern for Mutable Arrays</h3><h3 id="可变数组的搜索模式"><a href="#可变数组的搜索模式" class="headerlink" title="可变数组的搜索模式"></a>可变数组的搜索模式</h3><p>The default implementation of <a href="https://developer.apple.com/documentation/objectivec/nsobject/1416339-mutablearrayvalueforkey" target="_blank" rel="external"><code>mutableArrayValueForKey:</code></a>, given a <code>key</code> parameter as input, returns a mutable proxy array for a property named <code>key</code> inside the object receiving the accessor call, using the following procedure:</p>
<p><code>mutableArrayValueForKey:</code> 在给定 <code>key</code> 作为参数输入时的默认实现是返回一个可变的代理数组，当接收者收到该调用时，会执行以下流程：</p>
<ol>
<li><p>Look for a pair of methods with names like <code>insertObject:in&lt;Key&gt;AtIndex:</code> and <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> (corresponding to the <code>NSMutableArray</code> primitive methods<code>insertObject:atIndex:</code> and <code>removeObjectAtIndex:</code> respectively), or methods with names like <code>insert&lt;Key&gt;:atIndexes:</code> and <code>remove&lt;Key&gt;AtIndexes:</code> (corresponding to the <code>NSMutableArray</code> <code>insertObjects:atIndexes:</code> and <code>removeObjectsAtIndexes:</code> methods).</p>
<p>If the object has at least one insertion method and at least one removal method, return a proxy object that responds to <code>NSMutableArray</code> messages by sending some combination of <code>insertObject:in&lt;Key&gt;AtIndex:</code>, <code>removeObjectFrom&lt;Key&gt;AtIndex:</code>, <code>insert&lt;Key&gt;:atIndexes:</code>, and <code>remove&lt;Key&gt;AtIndexes:</code> messages to the original receiver of <code>mutableArrayValueForKey:</code>.</p>
<p>When the object receiving a <code>mutableArrayValueForKey:</code> message also implements an optional replace object method with a name like <code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> or <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>, the proxy object utilizes those as well when appropriate for best performance.</p>
<p>寻找一对名为  <code>insertObject:in&lt;Key&gt;AtIndex:</code> 和 <code>removeObjectFrom&lt;Key&gt;AtIndex:</code>  的方法（对应 <code>NSMutableArray</code> 中原始的 <code>insertObject:atIndex:</code>  和  <code>removeObjectAtIndex:</code> 方法），或者名为 <code>insert&lt;Key&gt;:atIndexes:</code> 和 <code>remove&lt;Key&gt;AtIndexes:</code> （对应 <code>NSMutableArray</code> 中的<code>insertObjects:atIndexes:</code> 和 <code>removeObjectsAtIndexes:</code> 方法）。</p>
<p>如果对象中至少存在一个增加方法和移除方法，那么会返回一个代理对象，该对象能够响应 <code>NSMutableArray</code> 的消息。</p>
<p>当一个对象接收 <code>mutableArrayValueForKey:</code> 消息时，也可以实现一个可选的方法，名字如 <code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> 和 <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>，代理对象在适当时也会使用这些代码以获得最佳性能。</p>
</li>
<li><p>If the object does not have the mutable array methods, look instead for an accessor method whose name matches the pattern <code>set&lt;Key&gt;:</code>. In this case, return a proxy object that responds to <code>NSMutableArray</code> messages by issuing a <code>set&lt;Key&gt;:</code> message to the original receiver of <code>mutableArrayValueForKey:</code>.</p>
<p>如果一个对象没有可变数组的方法，那么会查找方法名匹配  <code>set&lt;Key&gt;:</code> 的访问器方法。在这种情况下，通过向原始接收者发送一个 <code>set&lt;Key&gt;:</code> 方法来返回一个能够响应 <code>NSMutableArray</code> 方法的代理对象。</p>
<blockquote>
<p>NOTE</p>
<p>The mechanism described in this step is much less efficient than that of the previous step, because it may involve repeatedly creating new collection objects instead of modifying an existing one. Therefore, you should generally avoid it when designing your own key-value coding compliant objects.</p>
<p>注意</p>
<p>本步骤描述的机制比上一步的效率低得多，因为它可能涉及重复创建新的集合对象而不是修改现有的集合对象。 因此，在设计自己的 KVC 对象时通常应该避免它。</p>
</blockquote>
</li>
<li><p>If neither the mutable array methods, nor the accessor are found, and if the receiver’s class responds <code>YES</code> to <code>accessInstanceVariablesDirectly</code>, search for an instance variable with a name like <code>_&lt;key&gt;</code> or <code>&lt;key&gt;</code>, in that order.</p>
<p>If such an instance variable is found, return a proxy object that forwards each <code>NSMutableArray</code> message it receives to the instance variable’s value, which typically is an instance of <code>NSMutableArray</code> or one of its subclasses.</p>
<p>如果可变数组的方法和访问方法都没有找到，那么如果接收者的类方法 <code>accessInstanceVariablesDirectly</code> 返回的是 <code>YES</code> 的话，回根据  <code>_&lt;key&gt;</code> 和 <code>&lt;key&gt;</code> 的顺序查找实例变量。</p>
<p>如果该实例变量找到了，那么会返回一个代理对象，该代理对象会将它接收到的 <code>NSMutableArray</code> 的消息转发给找到的实例变量，该实例变量通常是 <code>NSMutableArray</code> 或者其子类的实例。</p>
</li>
<li><p>If all else fails, return a mutable collection proxy object that issues a <code>setValue:forUndefinedKey:</code>message to the original receiver of the <code>mutableArrayValueForKey:</code> message whenever it receives an <code>NSMutableArray</code> message.</p>
<p>The default implementation of <code>setValue:forUndefinedKey:</code> raises an <code>NSUndefinedKeyException</code>, but subclasses may override this behavior.</p>
<p>如果以上的步骤都失败了，那么会返回一个可变容器代理对象，该对象每接收到一个 <code>NSMutableArray</code> 的消息就会发送一个 <code>setValue:forUndefinedKey:</code> 消息给原始接收对象。</p>
<p><code>setValue:forUndefinedKey:</code> 方法的默认实现是抛出一个 <code>NSUndefinedKeyException</code> 异常，但是子类可以覆写该行为。</p>
</li>
</ol>
<h3 id="Search-Pattern-for-Mutable-Ordered-Sets"><a href="#Search-Pattern-for-Mutable-Ordered-Sets" class="headerlink" title="Search Pattern for Mutable Ordered Sets"></a>Search Pattern for Mutable Ordered Sets</h3><h3 id="可变有序集合的搜索模式（与-可变数组的搜索模式-的模式类似，不再重复翻译）"><a href="#可变有序集合的搜索模式（与-可变数组的搜索模式-的模式类似，不再重复翻译）" class="headerlink" title="可变有序集合的搜索模式（与 可变数组的搜索模式 的模式类似，不再重复翻译）"></a>可变有序集合的搜索模式（与 可变数组的搜索模式 的模式类似，不再重复翻译）</h3><p>The default implementation of <code>mutableOrderedSetValueForKey:</code> recognizes the same simple accessor methods and ordered set accessor methods as <code>valueForKey:</code> (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-138234" target="_blank" rel="external">Default Search Pattern for the Basic Getter</a>), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that <code>valueForKey:</code> returns. In addition, it does the following:</p>
<ol>
<li><p>Search for methods with names like <code>insertObject:in&lt;Key&gt;AtIndex:</code> and <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> (corresponding to the two most primitive methods defined by the <code>NSMutableOrderedSet</code> class), and also <code>insert&lt;Key&gt;:atIndexes:</code> and <code>remove&lt;Key&gt;AtIndexes:</code>(corresponding to <code>insertObjects:atIndexes:</code> and <code>removeObjectsAtIndexes:</code>).</p>
<p>If at least one insertion method and at least one removal method are found, the returned proxy object sends some combination of <code>insertObject:in&lt;Key&gt;AtIndex:</code>, <code>removeObjectFrom&lt;Key&gt;AtIndex:</code>, <code>insert&lt;Key&gt;:atIndexes:</code>, and <code>remove&lt;Key&gt;AtIndexes:</code> messages to the original receiver of the <code>mutableOrderedSetValueForKey:</code> message when it receives <code>NSMutableOrderedSet</code> messages.</p>
<p>The proxy object also makes use of methods with names like <code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> or <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code> when they exist in the original object.</p>
</li>
<li><p>If the mutable set methods are not found, search for an accessor method with a name like <code>set&lt;Key&gt;:</code>. In this case, the returned proxy object sends a <code>set&lt;Key&gt;:</code> message to the original receiver of <code>mutableOrderedSetValueForKey:</code> every time it receives a <code>NSMutableOrderedSet</code> message.</p>
<p>NOTEThe mechanism described in this step is much less efficient than that of the previous step, because it may involve repeatedly creating new collection objects instead of modifying an existing one. Therefore, you should generally avoid it when designing your own key-value coding compliant objects.</p>
</li>
<li><p>If neither the mutable set messages nor the accessor are found, and if the receiver’s <code>accessInstanceVariablesDirectly</code> class method returns <code>YES</code>, search for an instance variable with a name like <code>_&lt;key&gt;</code> or <code>&lt;key&gt;</code>, in that order. If such an instance variable is found, the returned proxy object forwards any <code>NSMutableOrderedSet</code> messages it receives to the instance variable’s value, which is typically an instance of <code>NSMutableOrderedSet</code> or one of its subclasses.</p>
</li>
<li><p>If all else fails, the returned proxy object sends a <code>setValue:forUndefinedKey:</code> message to the original receiver of <code>mutableOrderedSetValueForKey:</code> whenever it receives a mutable set message.</p>
<p>The default implementation of <code>setValue:forUndefinedKey:</code> raises an <code>NSUndefinedKeyException</code>, but objects may override this behavior.</p>
</li>
</ol>
<h3 id="Search-Pattern-for-Mutable-Sets"><a href="#Search-Pattern-for-Mutable-Sets" class="headerlink" title="Search Pattern for Mutable Sets"></a>Search Pattern for Mutable Sets</h3><h3 id="可变集合的搜索模式（与-可变有序集合的搜索模式-的模式类似，不再重复翻译）"><a href="#可变集合的搜索模式（与-可变有序集合的搜索模式-的模式类似，不再重复翻译）" class="headerlink" title="可变集合的搜索模式（与 可变有序集合的搜索模式 的模式类似，不再重复翻译）"></a>可变集合的搜索模式（与 可变有序集合的搜索模式 的模式类似，不再重复翻译）</h3><p>The default implementation of <code>mutableSetValueForKey:</code>, given a <code>key</code> parameter as input, returns a mutable proxy set for an array property named <code>key</code> inside the object receiving the accessor call, using the following procedure:</p>
<ol>
<li><p>Search for methods with names like <code>add&lt;Key&gt;Object:</code> and <code>remove&lt;Key&gt;Object:</code> (corresponding to the <code>NSMutableSet</code> primitive methods <code>addObject:</code> and <code>removeObject:</code> respectively) and also <code>add&lt;Key&gt;:</code> and <code>remove&lt;Key&gt;:</code> (corresponding to <code>NSMutableSet</code> methods <code>unionSet:</code> and <code>minusSet:</code>). If at least one addition method and at least one removal method are found, return a proxy object that sends some combination of <code>add&lt;Key&gt;Object:</code>, <code>remove&lt;Key&gt;Object:</code>, <code>add&lt;Key&gt;:</code>, and <code>remove&lt;Key&gt;:</code> messages to the original receiver of <code>mutableSetValueForKey:</code> for each <code>NSMutableSet</code> message it receives.</p>
<p>The proxy object also makes use of the methods with a name like <code>intersect&lt;Key&gt;:</code> or <code>set&lt;Key&gt;:</code> for best performance, if they are available.</p>
</li>
<li><p>If the receiver of the <code>mutableSetValueForKey:</code> call is a managed object, the search pattern does not continue as it would for non-managed objects. See Managed Object Accessor Methods in <em>Core Data Programming Guide</em> for more information.</p>
</li>
<li><p>If the mutable set methods are not found, and if the object is not a managed object, search for an accessor method with a name like <code>set&lt;Key&gt;:</code>. If such a method is found, the returned proxy object sends a <code>set&lt;Key&gt;:</code> message to the original receiver of <code>mutableSetValueForKey:</code> for each <code>NSMutableSet</code>message it receives.</p>
<p>NOTEThe mechanism described in this step is much less efficient than that of the first step, because it may involve repeatedly creating new collection objects instead of modifying an existing one. Therefore, you should generally avoid it when designing your own key-value coding compliant objects.</p>
</li>
<li><p>If the mutable set methods and the accessor method are not found, and if the <code>accessInstanceVariablesDirectly</code> class method returns <code>YES</code>, search for an instance variable with a name like <code>_&lt;key&gt;</code> or <code>&lt;key&gt;</code>, in that order. If such an instance variable is found, the proxy object forwards each <code>NSMutableSet</code> message it receives to the instance variable’s value, which is typically an instance of <code>NSMutableSet</code> or one of its subclasses.</p>
</li>
<li><p>If all else fails, the returned proxy object responds to any <code>NSMutableSet</code> message it receives by sending a <code>setValue:forUndefinedKey:</code> message to the original receiver of <code>mutableSetValueForKey:</code>.</p>
</li>
</ol>
<h2 id="Achieving-Basic-Key-Value-Coding-Compliance"><a href="#Achieving-Basic-Key-Value-Coding-Compliance" class="headerlink" title="Achieving Basic Key-Value Coding Compliance"></a>Achieving Basic Key-Value Coding Compliance</h2><h2 id="实现基础-KVC"><a href="#实现基础-KVC" class="headerlink" title="实现基础 KVC"></a>实现基础 KVC</h2><p>When adopting key-value coding for an object, you rely on the default implementation of the <code>NSKeyValueCoding</code> protocol by having your object inherit from <code>NSObject</code> or one of its many subclasses. The default implementation, in turn, relies on you to define your object’s instance variables (or <em>ivars</em>) and accessor methods following certain well-defined patterns, so that it can associate key strings with properties when it receives key-value coded messages, such as <code>valueForKey:</code> and <code>setValue:forKey:</code>.</p>
<p>当对对象采用 KVC 时，可以继承 <code>NSObject</code> 或者其子类来依赖 <code>NSKeyValueCoding</code> 协议的默认实现。相反的，默认实现依赖于你定义对象的实例变量和访问方法，这些实例变量和访问方法需要遵循良好的模式，因此可以在接收到 KVC 的消息时通过键字符串关联到属性，比如  <code>valueForKey:</code> 和 <code>setValue:forKey:</code> 方法。</p>
<p>You often adhere to the standard patterns in Objective-C by simply declaring a property using a <code>@property</code>statement, and allowing the compiler to automatically synthesize the ivar and accessors. The compiler follows the expected patterns by default.</p>
<p>你通常只需要使用 <code>@property</code> 来声明属性并允许编译器自动合成实例变量与访问方法，即可遵守 Objective-C 中的标准模式。编译器默认遵循预期的模式。</p>
<blockquote>
<p>NOTE</p>
<p>In Swift, simply declaring a property in the usual way produces the appropriate accessors automatically, and you never interact directly with ivars. For more information about properties in Swift, read <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14" target="_blank" rel="external">Properties</a> in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a>. For information specific to interacting with Objective-C properties from Swift, read <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID39" target="_blank" rel="external">Accessing Properties</a> in <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a>.</p>
<p>注意</p>
<p>在 Swift 中，只需用通常的方式声明一个属性即可自动生成相应的访问器，并且你无需与 实例变量 直接进行交互。参阅 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a> 中的 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14" target="_blank" rel="external">Properties</a> 获取更多关于 Swift 属性的信息。有关 Swift 和 Objective-C 相互作用的信息，参阅 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 4.1)</em></a> 中的  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID39" target="_blank" rel="external">Accessing Properties</a> 小节。</p>
</blockquote>
<p>If you do need to implement accessors or ivars manually in Objective-C, follow the guidelines in this section to maintain basic compliance. To provide additional functionality that enhances interaction with your object’s collection properties in any language, implement the methods described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a>. To further enhance your object with key-value validation, implement the methods described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/Validation.html#//apple_ref/doc/uid/20002173-CJBDBHCB" target="_blank" rel="external">Adding Validation</a>.</p>
<p>如果你确实需要在 Objective-C 中手动实现访问器或者变量，请遵循本节的指导以保持基本规范性。要提供增强与任何语言中对象的集合属性交互的附加功能，请实现 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a> 中描述的方法。要通过键值校验来进一步增强你的对象，请实现 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/Validation.html#//apple_ref/doc/uid/20002173-CJBDBHCB" target="_blank" rel="external">Adding Validation</a> 中描述的方法。</p>
<blockquote>
<p>NOTE</p>
<p>The default implementation of key-value coding works with a broader range of ivars and accessors than are described here. If you have legacy code that uses other variable or accessor conventions, examine the search patterns in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a> to determine if the default implementation can locate your object’s properties.</p>
<p>注意</p>
<p>KVC 的默认实现可以作用于更多没有在此描述的变量与访问器。如果你有使用其他变量以及访问器约定的遗留代码，检查  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a>  中的搜索模式以确定默认实现是否可以找到对象的属性。</p>
</blockquote>
<h3 id="Basic-Getters"><a href="#Basic-Getters" class="headerlink" title="Basic Getters"></a>Basic Getters</h3><h3 id="基础获取方法"><a href="#基础获取方法" class="headerlink" title="基础获取方法"></a>基础获取方法</h3><p>To implement a getter that returns the value of a property, while perhaps doing additional custom work, use a method named like the property, such as for the <code>title</code> string property:</p>
<p>要实现一个返回属性的 getter 方法，同时可能要做额外的自定义工作，请使用名称类似于属性的方法，例如 字符串类型的 <code>title</code> 的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSString*)title</div><div class="line">&#123;</div><div class="line">   // Extra getter logic…</div><div class="line"> </div><div class="line">   return _title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>For a property holding a Boolean value, you can alternatively use a method prefixed with <code>is</code>, such as for the <code>hidden</code> Boolean property:</p>
<p>对于一个 Boolean 类型的属性，你可以另外使用一个前缀为 <code>is</code> 的方法，例如一个 Boolean 类型的 <code>hidden</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isHidden</div><div class="line">&#123;</div><div class="line">   // Extra getter logic…</div><div class="line"> </div><div class="line">   return _hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When the property is a scalar or a structure, the default implementation of key-value coding wraps the value in an object for use on the protocol method’s interface, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>. You do not need to do anything special to support this behavior.</p>
<p>当一个属性是基本数据类型或者结构体时，KVC 的默认实现会将值根据  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 中描述的协议包装为对象返回。你不需要做任何特别的事情来支持该行为。</p>
<h3 id="Basic-Setters"><a href="#Basic-Setters" class="headerlink" title="Basic Setters"></a>Basic Setters</h3><h3 id="基础设置方法"><a href="#基础设置方法" class="headerlink" title="基础设置方法"></a>基础设置方法</h3><p>To implement a setter that stores the value of a property, use a method with the capitalized name of the property prefixed by the word <code>set</code>. For the <code>hidden</code> property:</p>
<p>实现存储属性值的 setter 方法，使用以 <code>set</code> 开头连接首字母大小的属性名作为方法名。对于 <code>hidden</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setHidden:(BOOL)hidden</div><div class="line">&#123;</div><div class="line">    // Extra setter logic…</div><div class="line"> </div><div class="line">   _hidden = hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>WARNING</p>
<p>Never call the validation methods described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/ValidatingProperties.html#//apple_ref/doc/uid/10000107i-CH18-SW1" target="_blank" rel="external">Validating Properties</a> from inside a <code>set&lt;Key&gt;:</code> method.</p>
<p>警告</p>
<p>在  <code>set&lt;Key&gt;:</code> 内部千万必要调用 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/ValidatingProperties.html#//apple_ref/doc/uid/10000107i-CH18-SW1" target="_blank" rel="external">Validating Properties</a> 中定义的验证方法。</p>
</blockquote>
<p>When a property is a non-object type, such as the Boolean <code>hidden</code>, the protocol’s default implementation detects the underlying data type, and unwraps the object value (an <code>NSNumber</code> instance in this case) that comes from <code>setValue:forKey:</code> before applying it to your setter, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>. You do not need to handle this in the setter itself. However, if there is a possibility that a <code>nil</code> value might be written to your non-object property, you override <a href="https://developer.apple.com/documentation/objectivec/nsobject/1415174-setnilvalueforkey" target="_blank" rel="external"><code>setNilValueForKey:</code></a> to handle this situation, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a>. An appropriate behavior for the <code>hidden</code> property might simply be to interpret <code>nil</code> as <code>NO</code>:</p>
<p>当你的属性是费对象类型时，比如 Boolean 类型的 <code>hidden</code> 属性，那么协议的默认实现会扫描底层数据类型并拆包（这里是 <code>NSNumber</code> 对象），像 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 描述的那样，这个行为发生在 <code>setValue:forKey:</code> 内在执行 setter 之前。你不需要在你的 setter 方法中处理。然而，还是有可能给你的非对象属性设置一个 <code>nil</code> 值，你可以重写  <a href="https://developer.apple.com/documentation/objectivec/nsobject/1415174-setnilvalueforkey" target="_blank" rel="external"><code>setNilValueForKey:</code></a>  方法来处理这个情况，像 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/HandlingNon-ObjectValues.html#//apple_ref/doc/uid/10000107i-CH5-SW1" target="_blank" rel="external">Handling Non-Object Values</a> 描述的那样。<code>hidden</code> 属性适当的做法可能是将 <code>nil</code> 简单的解释为 <code>NO</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setNilValueForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;hidden&quot;]) &#123;</div><div class="line">        [self setValue:@(NO) forKey:@”hidden”];</div><div class="line">    &#125; else &#123;</div><div class="line">        [super setNilValueForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>You provide the above method override, if appropriate, even when you allow the compiler to synthesize the setter.</p>
<p>如果合适，即使允许编译器合成 setter 方法，也可以提供上述方法进行覆盖。</p>
<h3 id="Instance-Variables"><a href="#Instance-Variables" class="headerlink" title="Instance Variables"></a>Instance Variables</h3><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>When the default implementation of one of the key-value coding accessor methods can’t find a property’s accessor, it queries its class’s <code>accessInstanceVariablesDirectly</code> method to see if the class allows direct use of instance variables. By default, this class method returns <code>YES</code>, although you can override this method to return <code>NO</code>.</p>
<p>当 KVC 的默认实现无法找到属性的访问器时，它会查询 <code>accessInstanceVariablesDirectly</code> 类方法来查看该类是否允许直接查找实例变量。默认情况下该方法都是返回 <code>YES</code>，你也可以覆写该方法来返回 <code>NO</code> 。</p>
<p>If you do allow use of ivars, ensure that they are named in the usual way, using the property name prefixed by an underscore (<code>_</code>). Normally, the compiler does this for you when automatically synthesizing properties, but if you use an explicit <code>@synthesize</code> directive, you can enforce this naming yourself:</p>
<p>如果你允许使用实例变量，请确认你的实例变量遵循常规命名，即在属性名字前加入下划线 <code>_</code> 作为实例变量名字。通常编译器会在自动合成变量的时候替你完成这件事，但是如果你使用一个明确的 <code>@synthesize</code> 指令，你可以自己强制命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@synthesize title = _title;</div></pre></td></tr></table></figure>
<p>In some cases, instead of using a <code>@synthesize</code> directive or allowing the compiler to automatically synthesize a property, you use a <code>@dynamic</code> directive to inform the compiler that you will provide getters and setters at runtime. You might do this to avoid automatically synthesizing a getter, so that you can provide collection accessors instead, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a>. In this, case you declare the ivar yourself as part of the interface declaration:</p>
<p>在某些情况下，你会使用 <code>@dynamic</code> 来指示编译器你会在运行时自己合成 getter 和 setter 方法，而不是使用 <code>@syntheszie</code> 来指示或者允许编译器自动合成属性。你可能会这样做来避免合成 getter 方法，因此你可以提供一个集合访问器来替代，就像 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a> 描述的那样。在这种情况下，你需要在你的类声明中声明该变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface MyObject : NSObject &#123;</div><div class="line">    NSString* _title;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@property (nonatomic) NSString* title;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="Defining-Collection-Methods"><a href="#Defining-Collection-Methods" class="headerlink" title="Defining Collection Methods"></a>Defining Collection Methods</h2><h2 id="定义容器方法"><a href="#定义容器方法" class="headerlink" title="定义容器方法"></a>定义容器方法</h2><p>When you create accessors and ivars using standard naming conventions, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessorConventions.html#//apple_ref/doc/uid/20002174-BAJEAIEE" target="_blank" rel="external">Achieving Basic Key-Value Coding Compliance</a>, the key-value coding protocol’s default implementation can locate them in response to key-value coded messages. This is as true for collection objects representing to-many relationships as it is for other properties. However, if you implement the collection accessor methods instead of, or in addition to, the basic accessors for a collection property, you can:</p>
<p>当你使用标准命名定义访问器和实例变量时，就像  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessorConventions.html#//apple_ref/doc/uid/20002174-BAJEAIEE" target="_blank" rel="external">Achieving Basic Key-Value Coding Compliance</a> 中描述的那样，KVC 的默认实现可以定位到它们从而响应 KVC 消息。这对于表示多对多的容器来说也是正确的，因为他们也是作为属性的。但是，如果实现集合访问器而不是集合属性的基本访问器，或者除此之外还可以执行以下操作：</p>
<ul>
<li><p><strong>Model to-many relationships with classes other than NSArray or NSSet.</strong> When you implement the collection methods in your object, the default implementation of the key-value getter returns a proxy object that calls these methods in response to subsequent <code>NSArray</code> or <code>NSSet</code> messages that it receives. The underlying property object need not be an <code>NSArray</code> or <code>NSSet</code> itself, because the proxy object provides the expected behavior using your collection methods.</p>
<p><strong>与NSArray或NSSet以外的类建立多对多关系。</strong> 当您在对象中实现容器方法时，KVC 的 getter 的默认实现会返回一个代理对象，该对象调用这些方法来响应接收到的后续 <code>NSArray</code> 或 <code>NSSet</code> 消息。 基础属性对象不必是 <code>NSArray</code> 或 <code>NSSet</code> 本身，因为代理对象使用你提供的容器方法提供预期的行为。</p>
</li>
<li><p><strong>Achieve increased performance when mutating the contents of a to-many relationship.</strong> Instead of repeatedly creating new collection objects with the basic setter in response to every change, the protocol’s default implementation uses your collection methods to mutate the underlying property in place.</p>
<p><strong>在改变多对多关系时实现更高的性能。</strong>协议的默认实现允许你使用容器方法改变基础属性而不是每次在 setter 中改变时都创建一个新的容器对象。</p>
</li>
<li><p><strong>Provide key-value observing compliant access to the contents of your object’s collection properties.</strong> For more information about key-value observing, read <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>.</p>
<p><strong>提供对对象集合属性内容的键值观察。</strong>参阅  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a> 获取更多关于 KVO 的信息。</p>
</li>
</ul>
<p>You implement one of two categories of collection accessors, depending on whether you want the relationship to behave like an indexed, ordered collection (like an <code>NSArray</code> object) or an unordered, uniqued collection (like an <code>NSSet</code> object). In either case, you implement at least one set of methods to support read access to the property, and then add an additional set to enable mutation of the collection’s contents.</p>
<p>你可以实现两种访问器中的一个，具体取决与你的对象是有序集合（像 <code>NSArray</code> 对象）还是无序且唯一的集合（像 <code>NSSet</code> 对象）。在任何一种情况下，你都应该至少实现一组方法来支持对属性的访问，然后可以添加额外的方法来支持更改集合的内容。</p>
<blockquote>
<p>NOTE</p>
<p>The key-value coding protocol does not declare the methods described in this section. Instead, the default implementation of the protocol provided by <code>NSObject</code> looks for these methods in your key-value coding compliant object, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a>, and uses them to handle key-value coded messages that are part of the protocol.</p>
<p>注意</p>
<p>KVC 协议没有声明本节中描述的方法。取而代之的是，<code>NSObject</code> 的对于协议的默认实现会根据 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">Accessor Search Patterns</a> 中描述的那样查找这些方法并处理 KVC 消息，这也是协议的一部分。</p>
</blockquote>
<h3 id="Accessing-Indexed-Collections"><a href="#Accessing-Indexed-Collections" class="headerlink" title="Accessing Indexed Collections"></a>Accessing Indexed Collections</h3><h3 id="容器索引访问器"><a href="#容器索引访问器" class="headerlink" title="容器索引访问器"></a>容器索引访问器</h3><p>You add indexed accessor methods to provide a mechanism for counting, retrieving, adding, and replacing objects in an ordered relationship. The underlying object is often an instance of <code>NSArray</code> or <code>NSMutableArray</code>, but if you provide the collection accessors, you enable any object property for which you implement these methods to be manipulated as if it were an array.</p>
<p>你可以添加索引访问方法来提供计数，检索，添加，替换排序关系中的对象的机制。底层的对象往往是 <code>NSArray</code> 或者 <code>NSMutableArray</code> 对象，但是如果你提供了容器访问方法，那么你可以启用任何实现这些方法的对象属性，就像使用数组一样。</p>
<h4 id="Indexed-Collection-Getters"><a href="#Indexed-Collection-Getters" class="headerlink" title="Indexed Collection Getters"></a>Indexed Collection Getters</h4><h4 id="容器索引获取方法"><a href="#容器索引获取方法" class="headerlink" title="容器索引获取方法"></a>容器索引获取方法</h4><p>For a collection property that has no default getter, if you provide the following indexed collection getter methods, the default implementation of the protocol, in response to a <code>valueForKey:</code> message, returns a proxy object that behaves like an <code>NSArray</code>, but calls the following collection methods to do its work.</p>
<p>对于容器属性来说没有默认的获取方法，如果你提供了以下的容器下标获取方法，协议对于 <code>valueForKey:</code> 的默认实现是返回一个行为像 <code>NSArray</code> 的代理对象，但是要调用下面的容器方法来完成工作。</p>
<blockquote>
<p>NOTE</p>
<p>In modern Objective-C, the compiler synthesizes a getter by default for each property, so the default implementation does <em>not</em> create a read only proxy that uses the methods in this section (note the accessor search order in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-138234" target="_blank" rel="external">Search Pattern for the Basic Getter</a>). You can get around this by either not declaring a property (relying solely on an ivar), or by declaring a property as <code>@dynamic</code>, indicating that you plan to supply accessor behavior at runtime. Either way, the compiler will not supply a default getter, and the default implementation uses the methods below.</p>
<p>注意</p>
<p>在现代 Objective-C 中，编译器默认为每个属性合成一个 getter 方法，因此默认实现不会创建本节中的方法只读代理（注意  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-138234" target="_blank" rel="external">Search Pattern for the Basic Getter</a> 中的访问器的搜索顺序）。你可以通过不声明一个属性（仅仅依赖一个变量），或者将属性声明 <code>@dynamic</code>，表明你将在运行时添加访问器方法。无论哪种方式，编译器都不会提供默认的 getter ，而默认的实现使用下面的方法。</p>
</blockquote>
<ul>
<li><code>countOf&lt;Key&gt;</code></li>
</ul>
<p>This method returns the number of objects in the to-many relationship as an <code>NSUInteger</code>, just like the <code>NSArray</code> primitive method <code>count</code>. In fact, when the underlying property is an <code>NSArray</code>, you use that method to provide a result.</p>
<p>该方法以 <code>NSUInteger</code> 类型返回多对多关系中的对象书，就像 <code>NSArray</code> 的 <code>count</code> 方法。事实上，当底层对象是 <code>NSArray</code> 实例时，你可以使用该方法(<code>count</code>)返回结果。</p>
<p>For example, for a to-many relationship representing a list of bank transactions and backed by an <code>NSArray</code> called <code>transactions</code>:</p>
<p>例如，对于代表银行交易清单并由 <code>NSArray</code> 支持的一对多的 <code>transactions</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)countOfTransactions &#123;</div><div class="line">    return [self.transactions count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>objectIn&lt;Key&gt;AtIndex:</code> or <code>&lt;key&gt;AtIndexes:</code></li>
</ul>
<p>The first returns the object at the specified index in the to-many relationship, while the second returns an array of objects at the indexes specified by the <code>NSIndexSet</code> parameter. These correspond to the <code>NSArray</code> methods <code>objectAtIndex:</code> and <code>objectsAtIndexes:</code>, respectively. You only need to implement one of these. The corresponding methods for the <code>transactions</code> array are:</p>
<p>第一个方法返回多对多关系中的指定索引的对象，而第二个方法是根据 <code>NSIndexSet</code> 参数返回指定索引对象构成的数组。这些方法分别对应 <code>NSArray</code> 中的  <code>objectAtIndex:</code> 和 <code>objectsAtIndexes:</code> 方法。你只需要实现其中一个即可。<code>transactions</code> 数组的对应方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)objectInTransactionsAtIndex:(NSUInteger)index &#123;</div><div class="line">    return [self.transactions objectAtIndex:index];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (NSArray *)transactionsAtIndexes:(NSIndexSet *)indexes &#123;</div><div class="line">    return [self.transactions objectsAtIndexes:indexes];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>get&lt;Key&gt;:range:</code></li>
</ul>
<p>This method is optional, but can result in improved performance. It returns the objects from the collection that fall within the specified range, and corresponds to the <code>NSArray</code> method <code>getObjects:range:</code>. The implementation for the transactions array is:</p>
<p>该方法是可选的，但是可以提高性能。该方法返回容器中指定范围内的所有对象，对应 <code>NSArray</code> 中的 <code>getObjects:range:</code> 方法。对于 transactions 数组可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)getTransactions:(Transaction * __unsafe_unretained *)buffer</div><div class="line">               range:(NSRange)inRange &#123;</div><div class="line">    [self.transactions getObjects:buffer range:inRange];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Indexed-Collection-Mutators"><a href="#Indexed-Collection-Mutators" class="headerlink" title="Indexed Collection Mutators"></a>Indexed Collection Mutators</h4><h4 id="索引容器修改器"><a href="#索引容器修改器" class="headerlink" title="索引容器修改器"></a>索引容器修改器</h4><p>Supporting a mutable to-many relationship with indexed accessors requires implementing a different group of methods. When you provide these setter methods, the default implementation, in response to the <code>mutableArrayValueForKey:</code> message, returns a proxy object that behaves like an <code>NSMutableArray</code> object, but uses your object’s methods to do its work. This is generally more efficient than returning an <code>NSMutableArray</code>object directly. It also enables the contents of a to-many relationship to be key-value observing compliant (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>).</p>
<p>通过索引方法支持可变容器还需要实现一组方法。当你提供 setter 方法，响应 <code>mutableArrayValueForKey:</code> 的默认实现会返回一个行为类似于 <code>NSMutableArray</code> 的代理对象，但是会使用你的方法进行工作。这通常比直接返回一个 <code>NSMutableArray</code> 对象更有效。它还可以使多对多关系的内容成为可以键值观察的对象 (参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>)。</p>
<p>In order to make your object key-value coding compliant for a mutable ordered to-many relationship, implement the following methods:</p>
<p>为了使你的 KVC 对象符合可变的有序多对多关系，需要实现以下方法：</p>
<ul>
<li><p><code>insertObject:in&lt;Key&gt;AtIndex:</code> or <code>insert&lt;Key&gt;:atIndexes:</code></p>
<p>The first receives the object to insert and an <code>NSUInteger</code> that specifies the index where it should be inserted. The second inserts an array of objects into the collection at the indices specified by the passed <code>NSIndexSet</code>. These are analogous to the <code>NSMutableArray</code> methods <code>insertObject:atIndex:</code> and <code>insertObjects:atIndexes:</code>. Only one of these methods is required.</p>
<p>第一个方法接收一个对象以及 <code>NSUInteger</code> 类型的需要插入的下标参数。第二个方法接收一个对象数组以及指定的 <code>NSIndexSet</code> 类型的索引对象。这些方法和 <code>NSMutableArray</code> 的 <code>insertObject:atIndex:</code> 和 <code>insertObjects:atIndexes:</code> 方法类型。这两个方法中只需要实现一个即可。</p>
<p>​</p>
<p>For a <code>transactions</code> object declared as an <code>NSMutableArray</code>:</p>
<p>对于一个声明为 <code>NSMutableArray</code> 的 <code>transactions</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)insertObject:(Transaction *)transaction</div><div class="line">  inTransactionsAtIndex:(NSUInteger)index &#123;</div><div class="line">    [self.transactions insertObject:transaction atIndex:index];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)insertTransactions:(NSArray *)transactionArray</div><div class="line">              atIndexes:(NSIndexSet *)indexes &#123;</div><div class="line">    [self.transactions insertObjects:transactionArray atIndexes:indexes];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><code>removeObjectFrom&lt;Key&gt;AtIndex:</code> or <code>remove&lt;Key&gt;AtIndexes:</code></p>
<p>The first receives an <code>NSUInteger</code> value specifying the index of the object to be removed from the relationship. The second receives an <code>NSIndexSet</code> object specifying the indexes of the objects to be removed from the relationship. These methods correspond to the <code>NSMutableArray</code> methods <code>removeObjectAtIndex:</code> and <code>removeObjectsAtIndexes:</code> respectively. Only one of these methods is required.</p>
<p>第一个方法接收一个 <code>NSUInteger</code> 类型的下标来移除对象。第二个方法接收一个 <code>NSIndexSet</code> 下标集合对象来移除对应的所有对象。这些方法和 <code>NSMutableArray</code> 中的 <code>removeObjectAtIndex:</code> 和 <code>removeObjectsAtIndexes:</code> 方法对应。只需要实现其中一个方法即可。</p>
<p>​</p>
<p>For the <code>transactions</code> object:</p>
<p>对于 <code>transactions</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)removeObjectFromTransactionsAtIndex:(NSUInteger)index &#123;</div><div class="line">    [self.transactions removeObjectAtIndex:index];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</div><div class="line">    [self.transactions removeObjectsAtIndexes:indexes];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p><code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> or <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></p>
<p>These replacement accessors provide the proxy object with a means to replace an object in the collection directly, without having to successively remove one object and insert another. They correspond to the <code>NSMutableArray</code> methods <code>replaceObjectAtIndex:withObject:</code> and <code>replaceObjectsAtIndexes:withObjects:</code>. You optionally provide these methods when profiling of your app reveals performance issues.</p>
<p>这些替换访问器为代理对象提供了直接替换集合中的对象的方法，而无需连续删除一个对象并插入另一个对象。这些方法和 <code>NSMutableArray</code> 中的 <code>replaceObjectAtIndex:withObject:</code> 和 <code>replaceObjectsAtIndexes:withObjects:</code> 方法对应。当你的 app 出现性能相关的问题时，可以选择性提供这些方法。</p>
<p>​</p>
<p>For the <code>transactions</code> object:</p>
<p>对于 <code>transactions</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)replaceObjectInTransactionsAtIndex:(NSUInteger)index</div><div class="line">                             withObject:(id)anObject &#123;</div><div class="line">    [self.transactions replaceObjectAtIndex:index</div><div class="line">                              withObject:anObject];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)replaceTransactionsAtIndexes:(NSIndexSet *)indexes</div><div class="line">                    withTransactions:(NSArray *)transactionArray &#123;</div><div class="line">    [self.transactions replaceObjectsAtIndexes:indexes</div><div class="line">                                withObjects:transactionArray];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="Accessing-Unordered-Collections"><a href="#Accessing-Unordered-Collections" class="headerlink" title="Accessing Unordered Collections"></a>Accessing Unordered Collections</h3><p>###访问无序的容器</p>
<p>You add unordered collection accessor methods to provide a mechanism for accessing and mutating objects in an unordered relationship. Typically, this relationship is an instance of an <code>NSSet</code> or <code>NSMutableSet</code> object. However, when you implement these accessors, you enable any class to model the relationship and be manipulated using key-value coding just as if it were an instance of <code>NSSet</code>.</p>
<p>你可以添加无序集合访问器方法以提供访问和变更无序关系中对象的机制。通常，这种关系时 <code>NSSet</code> 或者 <code>NSMutableSet</code> 对象。然而，当你实现这些访问器时，你可以启用任何类来实现这个关系，就像它是 <code>NSSet</code> 的实例一样。</p>
<h4 id="Unordered-Collection-Getters"><a href="#Unordered-Collection-Getters" class="headerlink" title="Unordered Collection Getters"></a>Unordered Collection Getters</h4><h4 id="无序容器获取方法"><a href="#无序容器获取方法" class="headerlink" title="无序容器获取方法"></a>无序容器获取方法</h4><p>When you provide the following collection getter methods to return the number of objects in the collection, iterate over the collection objects, and test if an object is already present in the collection, the default implementation of the protocol, in response to a <code>valueForKey:</code> message, returns a proxy object that behaves like an <code>NSSet</code>, but calls the following collection methods to do its work.</p>
<p>当您提供以下集合getter方法以返回集合中的对象数时，请迭代集合对象，并测试集合中是否已存在对象，响应<code>valueForKey:</code> 的默认实现会返回一个代理对象，其行为与 <code>NSSet</code> 相似，但会调用以下收集方法来完成其工作。</p>
<blockquote>
<p>NOTE</p>
<p>In modern Objective-C, the compiler synthesizes a getter by default for each property, so the default implementation does <em>not</em> create a read only proxy that uses the methods in this section (note the accessor search order in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-138234" target="_blank" rel="external">Search Pattern for the Basic Getter</a>). You can get around this by either not declaring a property (relying solely on an ivar), or by declaring a property as <code>@dynamic</code>, indicating that you plan to supply accessor behavior at runtime. Either way, the compiler will not supply a default getter, and the default implementation uses the methods below.</p>
<p>注意</p>
<p>在现代 Objective-C 中，编译器默认为每个属性合成一个 getter 方法，因此默认实现不会创建本节中的方法只读代理（注意  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-138234" target="_blank" rel="external">Search Pattern for the Basic Getter</a> 中的访问器的搜索顺序）。你可以通过不声明一个属性（仅仅依赖一个变量），或者将属性声明 <code>@dynamic</code>，表明你将在运行时添加访问器方法。无论哪种方式，编译器都不会提供默认的 getter ，而默认的实现使用下面的方法。</p>
</blockquote>
<ul>
<li><p><code>countOf&lt;Key&gt;</code></p>
<p>This required method returns the number of items in the relationship, corresponding to the <code>NSSet</code>method <code>count</code>. When the underlying object is an <code>NSSet</code>, you call on this method directly. For example, for an <code>NSSet</code> object called <code>employees</code> containing <code>Employee</code> objects:</p>
<p>该方法要求返回容器中的所有项的数量，对应 <code>NSSet</code> 的 <code>count</code> 方法。当底层对象是一个 <code>NSSet</code> 对象是，你可以直接调用该方法。例如，有一个 <code>NSSet</code> 类型的包含 <code>Employee</code> 对象的 <code>employees</code> 容器对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)countOfEmployees &#123;</div><div class="line">    return [self.employees count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>enumeratorOf&lt;Key&gt;</code></p>
<p>This required method returns an <code>NSEnumerator</code> instance that is used to iterate over the items in the relationship. See <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html#//apple_ref/doc/uid/20000135" target="_blank" rel="external">Enumeration: Traversing a Collection’s Elements</a> in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Collections.html#//apple_ref/doc/uid/10000034i" target="_blank" rel="external"><em>Collections Programming Topics</em></a> for more information about enumerators. The method corresponds to the <code>NSSet</code> method <code>objectEnumerator</code>. For the <code>employees</code> set:</p>
<p>该方法要求返回一个 <code>NSEnumerator</code> 实例用来遍历该容器。参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Collections.html#//apple_ref/doc/uid/10000034i" target="_blank" rel="external"><em>Collections Programming Topics</em></a> 中的 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html#//apple_ref/doc/uid/20000135" target="_blank" rel="external">Enumeration: Traversing a Collection’s Elements</a> 来获取更多关于遍历器的信息。该方法对应 <code>NSSet</code> 中的 <code>objectEnumerator</code> 方法。对于 <code>employees</code> 集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSEnumerator *)enumeratorOfEmployees &#123;</div><div class="line">    return [self.employees objectEnumerator];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>memberOf&lt;Key&gt;:</code>.</p>
<p>This method compares the object passed as a parameter with the contents of the collection and returns the matching object as a result, or <code>nil</code> if no matching object is found. If you implement comparisons manually, you typically use <code>isEqual:</code> to compare the objects. When the underlying object is an <code>NSSet</code> object, you can use the equivalent <code>member:</code> method:</p>
<p>该方法会根据传入的参数与集合的内容进行比较，并返回匹配的对象作为结果，如果没有找到匹配的对象，则会返回 <code>nil</code>。如果你手动执行比较，那么一般会使用 <code>isEqual:</code> 方法进行比较。当底层的对象是 <code>NSSet</code> 对象是，你可以使用等价的 <code>member:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (Employee *)memberOfEmployees:(Employee *)anObject &#123;</div><div class="line">    return [self.employees member:anObject];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Unordered-Collection-Mutators"><a href="#Unordered-Collection-Mutators" class="headerlink" title="Unordered Collection Mutators"></a>Unordered Collection Mutators</h4><h4 id="无序集合修改器"><a href="#无序集合修改器" class="headerlink" title="无序集合修改器"></a>无序集合修改器</h4><p>Supporting a mutable to-many relationship with unordered accessors requires implementing additional methods. Implement the mutable unordered accessors to allow your object to supply an unordered set proxy object in response to the <code>mutableSetValueForKey:</code> method. Implementing these accessors is much more efficient than relying on an accessor that returns a mutable object directly for making changes to the data in the relationship. It also makes your class key-value observing compliant for the collected objects (see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>).</p>
<p>支持修改可变无序集合，需要实现额外的方法。实现可变无序访问器，以允许对象响应 <code>mutableSetValueForKey:</code> 方法提供无序集合代理对象。实现这些访问器要比依赖返回可变对象的访问器直接更改关系中的数据更有效。它还可以使集合成为可以键值观察的对象 (参阅 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external"><em>Key-Value Observing Programming Guide</em></a>)。</p>
<p>In order to be key-value coding complaint for a mutable unordered to-many relationship implement the following methods:</p>
<p>为了使可变无序的对多关系对象符合 KVC，需要实现以下方法：</p>
<ul>
<li><p><code>add&lt;Key&gt;Object:</code> or <code>add&lt;Key&gt;:</code></p>
<p>These methods add a single item or a set of items to the relationship. When adding a set of items to the relationship, ensure that an equivalent object is not already present in the relationship. These are analogous to the <code>NSMutableSet</code> methods <code>addObject:</code> and <code>unionSet:</code>. Only one of these methods is required. For the <code>employees</code> set:</p>
<p>这些方法添加单个或者多个项目的集合到关系中。当你向关系中添加一组项目时，请确保在关系中不存在相等的对象。这些方法和 <code>NSMutableSet</code> 中的 <code>addObject:</code> 和 <code>unionSet:</code> 方法类似。只需要实现其中一个方法即可。对于 <code>employees</code> 集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)addEmployeesObject:(Employee *)anObject &#123;</div><div class="line">    [self.employees addObject:anObject];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)addEmployees:(NSSet *)manyObjects &#123;</div><div class="line">    [self.employees unionSet:manyObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><code>remove&lt;Key&gt;Object:</code> or <code>remove&lt;Key&gt;:</code></p>
<p>These methods remove a single item or a set of items from the relationship. They are analogous to the <code>NSMutableSet</code> methods <code>removeObject:</code> and <code>minusSet:</code>. Only one of these methods is required. For example:</p>
<p>这些方法移除关系中的一个或者多个项目的集合。这些方法和 <code>NSMutableSet</code> 中的 <code>removeObject:</code> 和 <code>minusSet:</code> 方法类似。只需要实现其中一个方法即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)removeEmployeesObject:(Employee *)anObject &#123;</div><div class="line">    [self.employees removeObject:anObject];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)removeEmployees:(NSSet *)manyObjects &#123;</div><div class="line">    [self.employees minusSet:manyObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p><code>intersect&lt;Key&gt;:</code></p>
<p>This method, which receives an <code>NSSet</code> parameter, removes from the relationship all the objects that aren’t common to both the input set and the collection set. This is the equivalent of the <code>NSMutableSet</code>method <code>intersectSet:</code>. You optionally implement this method when profiling indicates performance issues surrounding updates to the collection content. For example:</p>
<p>该方法接收一个 <code>NSSet</code> 参数，从关系中删除不是两者共同拥有的对象。该方法等效于 <code>NSMutableSet</code> 中的 <code>intersectSet:</code> 方法。当你遇到性能问题时，可以选择实现该方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)intersectEmployees:(NSSet *)otherObjects &#123;</div><div class="line">    return [self.employees intersectSet:otherObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="Handling-Non-Object-Values"><a href="#Handling-Non-Object-Values" class="headerlink" title="Handling Non-Object Values"></a>Handling Non-Object Values</h2><h2 id="处理非对象值"><a href="#处理非对象值" class="headerlink" title="处理非对象值"></a>处理非对象值</h2><p>Typically, your key-value coding compliant object relies on the default implementation of key-value coding to automatically wrap and unwrap non-object properties, as described in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>. However, you can override the default behavior. The most common reason to do so is to handle attempts to store a <code>nil</code> value on non-object properties.</p>
<p>通常你的 KVC 对象依赖于 KVC 中对非对象属性的自动包装与拆包，就如 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 中描述的那样。然而，你可以覆写该行为。这样做的最常见原因是处理在非对象属性上尝试设置 <code>nil</code>。</p>
<blockquote>
<p>NOTE</p>
<p>Because all properties in Swift are objects, this section only applies to Objective-C properties.</p>
<p>注意</p>
<p>由于 Swift 中所有属性都是对象，所以本小节只适用于 Objective-C 的属性。</p>
</blockquote>
<p>If your key-value coding compliant object receives a <code>setValue:forKey:</code> message with <code>nil</code> passed as the value for a non-object property, the default implementation has no appropriate, generalized course of action. It therefore sends itself a <code>setNilValueForKey:</code> message, which you can override. The default implementation of <code>setNilValueForKey:</code> raises an <code>NSInvalidArgumentException</code> exception, but you can provide an appropriate, implementation-specific behavior.</p>
<p>如果你的 KVC 对象接收到 value 为 <code>nil</code>  的 <code>setValue:forKey:</code> 方法去设置一个非对象属性，那么默认实现是没有恰当的通用的行为。因此它会向自己发送 <code>setNilValueForKey:</code> 消息，当然你可以自己重写它。 <code>setNilValueForKey:</code> 方法默认会抛出一个 <code>NSInvalidArgumentException</code> 异常，但是你可以提供适当的，实现特定的行为。</p>
<p>For example, the code in Listing 10-1 responds to an attempt to set a person’s age to a <code>nil</code> value by instead setting the age to 0, which is more appropriate for a floating point value. Notice that the override method calls upon its object’s superclass for any keys that it does not explicitly handle.</p>
<p>例如，清单10-1中的代码响应尝试将年龄设置为0来代替 <code>nil</code>，这更适合于浮点值。 请注意，重写后的方法会调用父类的方法来处理未明确处理的键。</p>
<p><strong>Listing 10-1 </strong>Example implementation of setNilValueForKey:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setNilValueForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;age&quot;]) &#123;</div><div class="line">        [self setValue:@(0) forKey:@”age”];</div><div class="line">    &#125; else &#123;</div><div class="line">        [super setNilValueForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE</p>
<p>For backward compatibility, when an object has overridden the deprecated <code>unableToSetNilForKey:</code>method, <code>setValue:forKey:</code> invokes that method instead of <code>setNilValueForKey:</code>.</p>
<p>注意</p>
<p>为了向后兼容，当一个对象重写了已经废弃的 <code>unableToSetNilForKey:</code> 方法时，<code>setValue:forKey:</code> 在这种情况下会调用 <code>unableToSetNilForKey:</code> 方法而不是 <code>setNilValueForKey:</code> 方法。</p>
</blockquote>
<h2 id="Adding-Validation"><a href="#Adding-Validation" class="headerlink" title="Adding Validation"></a>Adding Validation</h2><h2 id="添加校验"><a href="#添加校验" class="headerlink" title="添加校验"></a>添加校验</h2><p>The key-value coding protocol defines methods for validating properties by key or key path. The default implementation of these methods in turn rely on you to define methods following naming patterns similar to those used for accessor methods. Specifically, you provide a <code>validate&lt;Key&gt;:error:</code> method for any property with the name <code>key</code> that you want to validate. The default implementation searches for this in response to a key-coded <code>validateValue:forKey:error:</code> message.</p>
<p>KVC 协议定义了校验键和键路径的方法。这些方法的默认实现反过来依赖于你定义类似于用于访问方法的命名方式。特别的，你可以为名字为 <code>key</code> 的属性提供一个 <code>validate&lt;Key&gt;:error:</code> 的方法来校验。默认实现是通过键值编码的 <code>validateValue:forKey:error:</code> 方法来搜索的。</p>
<p>If you don’t supply a validation method for a property, the default implementation of the protocol assumes validation succeeds for that property, regardless of the value. This means that you opt in to validation on a property-by-property basis.</p>
<p>如果你不提供属性的校验方法，那么协议的默认实现会返回校验成功而不管传入的值。这意味着你需要选择属性来验证。</p>
<blockquote>
<p>NOTE</p>
<p>You typically use the validation described here only in Objective-C. In Swift, property validation is more idiomatically handled by relying on compiler support for optionals and strong type checking, while using the built-in <code>willSet</code> and <code>didSet</code> property observers to test any run-time API contracts, as described in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262" target="_blank" rel="external">Property Observers</a> section of <em>The Swift Programming Language (Swift 4.1)</em>.</p>
<p>注意</p>
<p>你通常只能在 Objective-C 中使用属性验证。在 Swift 中，属性验证通常依赖编译器支持的可选项和强类型检查，同时使用内置的 <code>willSet</code> 和 <code>didSet</code> 属性观察器来测试运行时的 API 约定，就像 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external"><em>The Swift Programming Language (Swift 4.1)</em></a> 中的 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262" target="_blank" rel="external">Property Observers</a>  章节描述的那样。</p>
</blockquote>
<h3 id="Implementing-a-Validation-Method"><a href="#Implementing-a-Validation-Method" class="headerlink" title="Implementing a Validation Method"></a>Implementing a Validation Method</h3><h3 id="实现一个校验方法"><a href="#实现一个校验方法" class="headerlink" title="实现一个校验方法"></a>实现一个校验方法</h3><p>When you do provide a validation method for a property, that method receives two parameters by reference: the value object to validate and the <code>NSError</code> used to return error information. As a result, your validation method can take one of three actions:</p>
<p>当你为一个属性提供校验方法时，该方法需要接收两个引用参数：被校验对象的引用以及用来返回错误信息的 <code>NSError</code> 引用。因此，你的验证结果可能是以下三种之一：</p>
<ul>
<li><p>When the value object is valid, return <code>YES</code> without altering the value object or the error.</p>
<p>当值是有效的，那么在不改变值或者 error 的情况下返回 <code>YES</code>。</p>
</li>
<li><p>When the value object isn’t valid, and you either can’t or don’t want to provide a valid alternative, set the error parameter to an <code>NSError</code> object that indicates the reason for failure and return <code>NO</code>.</p>
<p>当值是无效的并且你不想提供一个有效值，则返回 <code>NO</code> 并将传入的 error 设置一个用来指示失败原因的 <code>NSError</code> 对象。</p>
<blockquote>
<p>NOTE</p>
<p>Always test that an error reference is not <code>NULL</code> before trying to set it.</p>
<p>注意</p>
<p>在尝试设置 error 的引用之前，一定要测试它不是 <code>NULL</code>。</p>
</blockquote>
</li>
<li><p>When the value object isn’t valid, but you know of a valid alternative, create the valid object, assign the value reference to the new object, and return <code>YES</code> without modifying the error reference. If you provide another value, always return a new object rather than modifying the one being validated, even if the original object is mutable.</p>
<p>当值校验不通过时，但是你会创建一个新的有效的值来代替传入的值。在这种情况下，该方法会返回 <code>YES</code> 同时保持 error 不变。在返回之前，该方法会将值指向一个新的值。当它进行修改时，该方法总是会创建一个新的对象，而不是修改旧对象，即使旧对象是可变的。</p>
</li>
</ul>
<p>Listing 11-1 demonstrates a validation method for a <code>name</code> string property that ensures that the value object is not <code>nil</code> and that the name is a minimum length. This method does not substitute another value if validation fails.</p>
<p>清单11-1演示了字符串 <code>name</code> 属性的验证方法，该方法确保值对象不是零，并且名称是最小长度。如果验证失败，此方法不会用另外一个值来替代。</p>
<p><strong>Listing 11-1</strong> Validation method for the name property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateName:(id *)ioValue error:(NSError * __autoreleasing *)outError&#123;</div><div class="line">    if ((*ioValue == nil) || ([(NSString *)*ioValue length] &lt; 2)) &#123;</div><div class="line">        if (outError != NULL) &#123;</div><div class="line">            *outError = [NSError errorWithDomain:PersonErrorDomain</div><div class="line">                                            code:PersonInvalidNameCode</div><div class="line">                                        userInfo:@&#123; NSLocalizedDescriptionKey</div><div class="line">                                                    : @&quot;Name too short&quot; &#125;];</div><div class="line">        &#125;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Validation-of-Scalar-Values"><a href="#Validation-of-Scalar-Values" class="headerlink" title="Validation of Scalar Values"></a>Validation of Scalar Values</h3><h3 id="校验基本数据类型值"><a href="#校验基本数据类型值" class="headerlink" title="校验基本数据类型值"></a>校验基本数据类型值</h3><p>Validation methods expect the value parameter to be an object, and as a result, values for non-object properties are wrapped in an <code>NSValue</code> or <code>NSNumber</code> object, as discussed in <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a>. The example in Listing 11-2 demonstrates a validation method for the scalar property <code>age</code>. In this case, one potential invalid condition, namely a <code>nil</code> <code>age</code> value, is handled by creating a valid value set to zero, and returning <code>YES</code>. You might also handle this particular condition in your <code>setNilValueForKey:</code> override, because a user of your class might not invoke the validation method.</p>
<p>验证方法希望 value 参数是一个对象，因此，非对象属性会被包装成 <code>NSValue</code> 或者 <code>NSNmuber</code> 对象，就像 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE" target="_blank" rel="external">Representing Non-Object Values</a> 中描述的那样。清单11-2中的例子演示了基本数据类型 <code>age</code> 属性的验证方法。在这种情况下，通过创建一个设置为零的有效值来处理一个潜在的无效条件，即 <code>nil</code> <code>age</code>，并返回 <code>YES</code>。你也可以重写 <code>setNilValueForKey:</code> 方法来处理这个特定的条件，因为你的类可能不会调用校验方法。</p>
<p><strong>Listing 11-2</strong> Validation method for a scalar property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateAge:(id *)ioValue error:(NSError * __autoreleasing *)outError &#123;</div><div class="line">    if (*ioValue == nil) &#123;</div><div class="line">        // Value is nil: Might also handle in setNilValueForKey</div><div class="line">        *ioValue = @(0);</div><div class="line">    &#125; else if ([*ioValue floatValue] &lt; 0.0) &#123;</div><div class="line">        if (outError != NULL) &#123;</div><div class="line">            *outError = [NSError errorWithDomain:PersonErrorDomain</div><div class="line">                                            code:PersonInvalidAgeCode</div><div class="line">                                        userInfo:@&#123; NSLocalizedDescriptionKey</div><div class="line">                                                    : @&quot;Age cannot be negative&quot; &#125;];</div><div class="line">        &#125;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Describing-Property-Relationships"><a href="#Describing-Property-Relationships" class="headerlink" title="Describing Property Relationships"></a>Describing Property Relationships</h2><h2 id="描述属性关系"><a href="#描述属性关系" class="headerlink" title="描述属性关系"></a>描述属性关系</h2><p>Class descriptions provide a method of describing the to-one and to-many properties in a class. Defining these relationships between class properties allows for more intelligent and flexible manipulation of these properties with key-value coding.</p>
<p>类描述提供了描述类中的一对一和一对多属性的方法。在类属性中定义这些关系能够使得 KVC 更智能和更灵活地处理这些属性。</p>
<h3 id="Class-Descriptions"><a href="#Class-Descriptions" class="headerlink" title="Class Descriptions"></a>Class Descriptions</h3><h3 id="类描述"><a href="#类描述" class="headerlink" title="类描述"></a>类描述</h3><p><code>NSClassDescription</code> is a base class that provides the interface for obtaining meta-data about classes. A class description object records the available attributes of objects of a particular class and the relationships (one-to-one, one-to-many, and inverse) between objects of that class and other objects. For example the <code>attributeKeys</code> method returns the list of all attributes defined for a class; the methods <code>toManyRelationshipKeys</code> and <code>toOneRelationshipKeys</code> return arrays of keys that define to-many and to-one relationships; and <code>inverseRelationshipKey:</code> returns the name of the relationship pointing back to the receiver from the destination of the relationship for the provided key.</p>
<p><code>NSClassDescription</code> 是一个基类，它提供了获取有关类的元数据的接口。一个 class description 对象记录了特定类的对象的可用属性以及和其他类对象之间的关系（一对一，一对多，反向）。例如， <code>attributeKeys</code> 方法返回了类中第一的所有属性的列表；<code>toManyRelationshipKeys</code> 和 <code>toOneRelationshipKeys</code> 方法返回定义一对一、一对多关系的关键字数组；<code>inverseRelationshipKey:</code> 返回从所提供的关键字的关系目的地指向接收方的名称。</p>
<p><code>NSClassDescription</code> does not define methods for defining the relationships. Concrete subclasses must define these methods. Once created, you register a class description with the NSClassDescription <code>registerClassDescription:forClass:</code> class method.</p>
<p><code>NSClassDescription</code> 没有定义定义关系的方法。具体的子类必须定义这些方法。一旦创建，你就可以使用 NSClassDescription 的 <code>registerClassDescription:forClass:</code> 类方法来注册类描述。</p>
<p><code>NSScriptClassDescription</code> is the only concrete subclass of NSClassDescription provided in Cocoa. It encapsulates an application’s scripting information.</p>
<p><code>NSScriptClassDescription</code> 是唯一一个在 Cocoa 中提供的具体子类。它封装了应用程序的脚本信息。</p>
<h2 id="Designing-for-Performance"><a href="#Designing-for-Performance" class="headerlink" title="Designing for Performance"></a>Designing for Performance</h2><h2 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h2><p>Key-value coding is efficient, especially when you rely on the default implementation to do most of the work, but it does add a level of indirection that is slightly slower than direct method invocations. Use key-value coding only when you can benefit from the flexibility that it provides, or to allow your objects to participate in the Cocoa technologies that depend on it.</p>
<p>KVC 非常高效，特别是当你依赖默认实现完成部分工作时，但它确实增加了一个比直接方法调用稍慢的间接级别。只有当你可以从 KVC 提供的灵活性中受益，或者允许你的对象参与依赖于它的 Cocoa 技术时，才使用 KVC 。</p>
<h3 id="Overriding-Key-Value-Coding-Methods"><a href="#Overriding-Key-Value-Coding-Methods" class="headerlink" title="Overriding Key-Value Coding Methods"></a>Overriding Key-Value Coding Methods</h3><h3 id="重写-KVC-方法"><a href="#重写-KVC-方法" class="headerlink" title="重写 KVC 方法"></a>重写 KVC 方法</h3><p>Typically, you make your objects key-value coding compliant by ensuring that they inherit from <code>NSObject</code>, and then providing the property-specific accessors and related methods as described throughout this book. You rarely need to override the default implementations of the key-value coded accessors, such as <code>valueForKey:</code>and <code>setValue:forKey:</code>, or the key-based validation methods like <code>validateValue:forKey:</code>. Because these implementations cache information about the runtime environment to increase efficiency, if you do override them to introduce custom logic, make sure that you invoke the default implementation in the superclass before returning.</p>
<p>通常，通过确保你的对象继承自 <code>NSObject</code> ，并且使用本书描述的特定的指定属性和访问器方法，来使得你的对象能够符合 KVC。你很少需要重写 KVC 方法方法的实现，比如 <code>valueForKey:</code> 和 <code>setValue:forKey:</code>，以及基于键的验证方法 <code>validateValue:forKey:</code> 。因为这些方法的默认实现会通过运行时环境来缓存信息并提高性能，如果你确实需要通过重写来增加自定义逻辑，那么请确保你在方法返回前通过 superclass 来调用默认实现。</p>
<h3 id="Optimizing-To-Many-Relationships"><a href="#Optimizing-To-Many-Relationships" class="headerlink" title="Optimizing To-Many Relationships"></a>Optimizing To-Many Relationships</h3><h3 id="优化多对多关系"><a href="#优化多对多关系" class="headerlink" title="优化多对多关系"></a>优化多对多关系</h3><p>When you implement to-many relationships, the indexed form of the accessors provides significant performance gains in many cases, especially for mutable collections. See <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessingCollectionProperties.html#//apple_ref/doc/uid/10000107i-CH4-SW1" target="_blank" rel="external">Accessing Collection Properties</a> and <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a> for further information.</p>
<p>当你实现多对多关系时，访问器的索引在许多情况下都会显着提高性能，特别是对于可变集合。参阅  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/AccessingCollectionProperties.html#//apple_ref/doc/uid/10000107i-CH4-SW1" target="_blank" rel="external">Accessing Collection Properties</a> 和 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/DefiningCollectionMethods.html#//apple_ref/doc/uid/10000107i-CH17-SW1" target="_blank" rel="external">Defining Collection Methods</a> 获取更多信息。</p>
<h2 id="Compliance-Checklist"><a href="#Compliance-Checklist" class="headerlink" title="Compliance Checklist"></a>Compliance Checklist</h2><h2 id="规范性清单"><a href="#规范性清单" class="headerlink" title="规范性清单"></a>规范性清单</h2><p>Follow the steps summarized in this section to ensure your objects are key-value coding compliant. See the previous sections for details.</p>
<p>按照本节中总结的步骤确保您的对象符合 KVC。细节请查看之前的小节。</p>
<h3 id="Attribute-and-To-One-Relationship-Compliance"><a href="#Attribute-and-To-One-Relationship-Compliance" class="headerlink" title="Attribute and To-One Relationship Compliance"></a>Attribute and To-One Relationship Compliance</h3><h3 id="属性和一对一关系规范"><a href="#属性和一对一关系规范" class="headerlink" title="属性和一对一关系规范"></a>属性和一对一关系规范</h3><p>For each property that is an attribute or a to-one relationship:</p>
<p>对于属性或一对一关系的每个属性：</p>
<ul>
<li><p>Implement a method named <code>&lt;key&gt;</code> or <code>is&lt;Key&gt;</code>, or create an instance variable <code>&lt;key&gt;</code> or <code>_&lt;key&gt;</code>. The compiler typically does this for you when it automatically synthesizes properties.</p>
</li>
<li><p>实现 <code>&lt;key&gt;</code> 或者 <code>is&lt;Key&gt;</code> 方法，或者创建 <code>&lt;key&gt;</code> 或者 <code>_&lt;key&gt;</code> 实例变量。在你使用自动合成属性时编译器通常会帮你做这些。</p>
<blockquote>
<p>NOTE</p>
<p>Although property names frequently begin with a lowercase letter, the default implementation of the protocol also works with names that begin with an uppercase letter, such as <code>URL</code>.</p>
<p>注意</p>
<p>尽管属性常常以小写字母开头，但是协议的默认实现通常对于名字以大写字母开头的属性生效，例如 <code>URL</code>。</p>
</blockquote>
</li>
<li><p>If the property is mutable, implement the <code>set&lt;Key&gt;:</code> method. The compiler typically does this for you when you allow it to automatically synthesize your properties.</p>
</li>
<li><p>如果一个属性是可变的，请实现 <code>set&lt;Key&gt;:</code> 方法。在你使用自动合成属性时编译器通常会帮你做这些。</p>
<blockquote>
<p>IMPORTANT</p>
<p>If you override the default setter, be sure not to invoke any of the protocol’s validation methods.</p>
<p>重要</p>
<p>如果你重写了默认的 setter ，请确保你在 setter 中不要调用任何协议中的验证方法。</p>
</blockquote>
</li>
<li><p>If the property is a scalar, override the <code>setNilValueForKey:</code> method to gracefully handle the case where a <code>nil</code> value is assigned to the scalar property.</p>
</li>
<li><p>如果一个属性是基本类型，重写 <code>setNilValueForKey:</code> 方法来优雅地处理赋值 <code>nil</code> 的情况。</p>
</li>
</ul>
<h3 id="Indexed-To-Many-Relationship-Compliance"><a href="#Indexed-To-Many-Relationship-Compliance" class="headerlink" title="Indexed To-Many Relationship Compliance"></a>Indexed To-Many Relationship Compliance</h3><h3 id="索引多对多关系规范性"><a href="#索引多对多关系规范性" class="headerlink" title="索引多对多关系规范性"></a>索引多对多关系规范性</h3><p>For each property that is an ordered, to-many relationship (such as an <code>NSArray</code> object):</p>
<p>每一个有序的多对多关系属性（例如 <code>NSArray</code> 对象）：</p>
<ul>
<li>Implement a method named <code>&lt;key&gt;</code> that returns an array, or have an array instance variable named <code>&lt;key&gt;</code> or <code>_&lt;key&gt;</code>. The compiler typically does this for you when it automatically synthesizes properties.</li>
<li>实现返回数组的 <code>&lt;key&gt;</code> 方法，或者是数组类型名字为 <code>&lt;key&gt;</code> 或者 <code>_&lt;key&gt;</code> 的实例变量。</li>
<li>Alternatively, implement the method <code>countOf&lt;Key&gt;</code> and one or both of <code>objectIn&lt;Key&gt;AtIndex:</code> and <code>&lt;key&gt;AtIndexes:</code>.</li>
<li>另外，实现 <code>countOf&lt;Key&gt;</code> 方法， 实现 <code>objectIn&lt;Key&gt;AtIndex:</code> 和 <code>&lt;key&gt;AtIndexes:</code>两者或者两者之一。</li>
<li>Optionally, implement <code>get&lt;Key&gt;:range:</code> to improve performance.</li>
<li>实现 <code>get&lt;Key&gt;:range:</code> 方法可以提高性能，但是这是可选的。</li>
</ul>
<p>In addition, if the property is mutable:</p>
<p>另外，如果一个属性是可变的：</p>
<ul>
<li>Implement one or both of the methods <code>insertObject:in&lt;Key&gt;AtIndex:</code> and <code>insert&lt;Key&gt;:atIndexes:</code>.</li>
<li>实现<code>insertObject:in&lt;Key&gt;AtIndex:</code> 和 <code>insert&lt;Key&gt;:atIndexes:</code> 两者或者两者之一。</li>
<li>Implement one or both of the methods <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> and <code>remove&lt;Key&gt;AtIndexes:</code>.</li>
<li>实现 <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> 和 <code>remove&lt;Key&gt;AtIndexes:</code> 两者或者两者之一。</li>
<li>Optionally, implement <code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> or <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code> to improve performance.</li>
<li>实现 <code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code> 或者 <code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>  可以提高性能，但是这是可选的。</li>
</ul>
<h3 id="Unordered-To-Many-Relationship-Compliance"><a href="#Unordered-To-Many-Relationship-Compliance" class="headerlink" title="Unordered To-Many Relationship Compliance"></a>Unordered To-Many Relationship Compliance</h3><h3 id="无序多对多关系规范性"><a href="#无序多对多关系规范性" class="headerlink" title="无序多对多关系规范性"></a>无序多对多关系规范性</h3><p>For each property that is an unordered, to-many relationship (such as an <code>NSSet</code> object):</p>
<p>对于每一个多对多的无序属性（比如 <code>NSSet</code> 对象）：</p>
<ul>
<li>Implement the <code>&lt;key&gt;</code> that returns a set, or have an <code>NSSet</code> instance variable named <code>&lt;key&gt;</code> or <code>_&lt;key&gt;</code>. The compiler typically does this for you when it automatically synthesizes properties.</li>
<li>实现 <code>&lt;key&gt;</code> 方法返回一个 集合，或者有名字为  <code>&lt;key&gt;</code> 或者 <code>_&lt;key&gt;</code> 的 <code>NSSet</code> 类型的实例变量。在你使用自动合成属性时编译器通常会帮你做这些。</li>
<li>Alternatively, implement the methods <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, and <code>memberOf&lt;Key&gt;:</code>.</li>
<li>另外，实现 <code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>, 和 <code>memberOf&lt;Key&gt;:</code> 方法。</li>
</ul>
<p>In addition, if the property is mutable:</p>
<p>另外，如果属性是可变的：</p>
<ul>
<li>Implement one or both of the methods <code>add&lt;Key&gt;Object:</code> and <code>add&lt;Key&gt;:</code>.</li>
<li>实现 <code>add&lt;Key&gt;Object:</code> 和 <code>add&lt;Key&gt;:</code> 两者或者两者之一。</li>
<li>Implement one or both of the methods <code>remove&lt;Key&gt;Object:</code> and <code>remove&lt;Key&gt;:</code>.</li>
<li>实现 <code>remove&lt;Key&gt;Object:</code> 和 <code>remove&lt;Key&gt;:</code> 两者或者两者之一。</li>
<li>Optionally, implement <code>intersect&lt;Key&gt;:</code> to improve performance.</li>
<li>实现 <code>intersect&lt;Key&gt;:</code> 方法可以提高性能，这是可选的。</li>
</ul>
<h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>Opt in to validation for properties that need it:</p>
<p>选择验证的属性需要这些：</p>
<ul>
<li>Implement the <code>validate&lt;Key&gt;:error:</code> method, returning a boolean indicating the validity of the value, and a reference to an error object when appropriate.</li>
<li>实现  <code>validate&lt;Key&gt;:error:</code> 方法，返回指示合法性的 boolean 值，并在合适的时机返回一个错误对象的引用。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/25/UIFeedbackGenerator/" rel="next" title="UIFeedbackGenerator 翻译一篇">
                <i class="fa fa-chevron-left"></i> UIFeedbackGenerator 翻译一篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/01/分页请求注意事项/" rel="prev" title="分页请求注意事项">
                分页请求注意事项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jc_logo.png"
               alt="jcapp" />
          <p class="site-author-name" itemprop="name">jcapp</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#About-Key-Value-Coding"><span class="nav-number">1.</span> <span class="nav-text">About Key-Value Coding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于键值编码"><span class="nav-number">2.</span> <span class="nav-text">关于键值编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Key-Value-Coding-Compliant-Objects"><span class="nav-number">2.1.</span> <span class="nav-text">Using Key-Value Coding Compliant Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用符合键值编码的对象"><span class="nav-number">2.2.</span> <span class="nav-text">使用符合键值编码的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adopting-Key-Value-Coding-for-an-Object"><span class="nav-number">2.3.</span> <span class="nav-text">Adopting Key-Value Coding for an Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为一个对象采用键值编码"><span class="nav-number">2.4.</span> <span class="nav-text">为一个对象采用键值编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-Value-Coding-with-Swift"><span class="nav-number">2.5.</span> <span class="nav-text">Key-Value Coding with Swift</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift-中的键值编码"><span class="nav-number">2.6.</span> <span class="nav-text">Swift 中的键值编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Cocoa-Technologies-Rely-on-Key-Value-Coding"><span class="nav-number">2.7.</span> <span class="nav-text">Other Cocoa Technologies Rely on Key-Value Coding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cocoa-中其他依赖键值编码的技术"><span class="nav-number">2.8.</span> <span class="nav-text">Cocoa 中其他依赖键值编码的技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Accessing-Object-Properties"><span class="nav-number">3.</span> <span class="nav-text">Accessing Object Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问对象的属性"><span class="nav-number">4.</span> <span class="nav-text">访问对象的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Identifying-an-Object’s-Properties-with-Keys-and-Key-Paths"><span class="nav-number">4.1.</span> <span class="nav-text">Identifying an Object’s Properties with Keys and Key Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用键和关键路径确定对象的属性"><span class="nav-number">4.2.</span> <span class="nav-text">用键和关键路径确定对象的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Getting-Attribute-Values-Using-Keys"><span class="nav-number">4.3.</span> <span class="nav-text">Getting Attribute Values Using Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用键获取属性值"><span class="nav-number">4.4.</span> <span class="nav-text">使用键获取属性值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-Attribute-Values-Using-Keys"><span class="nav-number">4.5.</span> <span class="nav-text">Setting Attribute Values Using Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用键设置属性值"><span class="nav-number">4.6.</span> <span class="nav-text">使用键设置属性值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Keys-to-Simplify-Object-Access"><span class="nav-number">4.7.</span> <span class="nav-text">Using Keys to Simplify Object Access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用键来简化对象访问"><span class="nav-number">4.8.</span> <span class="nav-text">使用键来简化对象访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Accessing-Collection-Properties"><span class="nav-number">5.</span> <span class="nav-text">Accessing Collection Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问集合属性"><span class="nav-number">6.</span> <span class="nav-text">访问集合属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Collection-Operators"><span class="nav-number">7.</span> <span class="nav-text">Using Collection Operators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用集合运算符"><span class="nav-number">8.</span> <span class="nav-text">使用集合运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sample-Data"><span class="nav-number">8.1.</span> <span class="nav-text">Sample Data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aggregation-Operators"><span class="nav-number">8.2.</span> <span class="nav-text">Aggregation Operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合操作"><span class="nav-number">8.3.</span> <span class="nav-text">聚合操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#avg"><span class="nav-number">8.3.1.</span> <span class="nav-text">@avg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#count"><span class="nav-number">8.3.2.</span> <span class="nav-text">@count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max"><span class="nav-number">8.3.3.</span> <span class="nav-text">@max</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#min"><span class="nav-number">8.3.4.</span> <span class="nav-text">@min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sum"><span class="nav-number">8.3.5.</span> <span class="nav-text">@sum</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-Operators"><span class="nav-number">8.4.</span> <span class="nav-text">Array Operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组操作"><span class="nav-number">8.5.</span> <span class="nav-text">数组操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#distinctUnionOfObjects"><span class="nav-number">8.5.1.</span> <span class="nav-text">@distinctUnionOfObjects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unionOfObjects"><span class="nav-number">8.5.2.</span> <span class="nav-text">@unionOfObjects</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nesting-Operators"><span class="nav-number">8.6.</span> <span class="nav-text">Nesting Operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套操作"><span class="nav-number">8.7.</span> <span class="nav-text">嵌套操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#distinctUnionOfArrays"><span class="nav-number">8.7.1.</span> <span class="nav-text">@distinctUnionOfArrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unionOfArrays"><span class="nav-number">8.7.2.</span> <span class="nav-text">@unionOfArrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#distinctUnionOfSets"><span class="nav-number">8.7.3.</span> <span class="nav-text">@distinctUnionOfSets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Representing-Non-Object-Values"><span class="nav-number">9.</span> <span class="nav-text">Representing Non-Object Values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表示非对象值"><span class="nav-number">10.</span> <span class="nav-text">表示非对象值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrapping-and-Unwrapping-Scalar-Types"><span class="nav-number">10.1.</span> <span class="nav-text">Wrapping and Unwrapping Scalar Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装以及拆包基本数据类型"><span class="nav-number">10.2.</span> <span class="nav-text">包装以及拆包基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrapping-and-Unwrapping-Structures"><span class="nav-number">10.3.</span> <span class="nav-text">Wrapping and Unwrapping Structures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装以及拆包结构体"><span class="nav-number">10.4.</span> <span class="nav-text">包装以及拆包结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Validating-Properties"><span class="nav-number">11.</span> <span class="nav-text">Validating Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证属性"><span class="nav-number">12.</span> <span class="nav-text">验证属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Automatic-Validation"><span class="nav-number">12.1.</span> <span class="nav-text">Automatic Validation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动验证"><span class="nav-number">12.2.</span> <span class="nav-text">自动验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Accessor-Search-Patterns"><span class="nav-number">13.</span> <span class="nav-text">Accessor Search Patterns</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问器搜索模式"><span class="nav-number">14.</span> <span class="nav-text">访问器搜索模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-Pattern-for-the-Basic-Getter"><span class="nav-number">14.1.</span> <span class="nav-text">Search Pattern for the Basic Getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取方法的搜索模式"><span class="nav-number">14.2.</span> <span class="nav-text">获取方法的搜索模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-Pattern-for-the-Basic-Setter"><span class="nav-number">14.3.</span> <span class="nav-text">Search Pattern for the Basic Setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置方法的搜索模式"><span class="nav-number">14.4.</span> <span class="nav-text">设置方法的搜索模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-Pattern-for-Mutable-Arrays"><span class="nav-number">14.5.</span> <span class="nav-text">Search Pattern for Mutable Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变数组的搜索模式"><span class="nav-number">14.6.</span> <span class="nav-text">可变数组的搜索模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-Pattern-for-Mutable-Ordered-Sets"><span class="nav-number">14.7.</span> <span class="nav-text">Search Pattern for Mutable Ordered Sets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变有序集合的搜索模式（与-可变数组的搜索模式-的模式类似，不再重复翻译）"><span class="nav-number">14.8.</span> <span class="nav-text">可变有序集合的搜索模式（与 可变数组的搜索模式 的模式类似，不再重复翻译）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-Pattern-for-Mutable-Sets"><span class="nav-number">14.9.</span> <span class="nav-text">Search Pattern for Mutable Sets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变集合的搜索模式（与-可变有序集合的搜索模式-的模式类似，不再重复翻译）"><span class="nav-number">14.10.</span> <span class="nav-text">可变集合的搜索模式（与 可变有序集合的搜索模式 的模式类似，不再重复翻译）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Achieving-Basic-Key-Value-Coding-Compliance"><span class="nav-number">15.</span> <span class="nav-text">Achieving Basic Key-Value Coding Compliance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现基础-KVC"><span class="nav-number">16.</span> <span class="nav-text">实现基础 KVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Getters"><span class="nav-number">16.1.</span> <span class="nav-text">Basic Getters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础获取方法"><span class="nav-number">16.2.</span> <span class="nav-text">基础获取方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Setters"><span class="nav-number">16.3.</span> <span class="nav-text">Basic Setters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础设置方法"><span class="nav-number">16.4.</span> <span class="nav-text">基础设置方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instance-Variables"><span class="nav-number">16.5.</span> <span class="nav-text">Instance Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例变量"><span class="nav-number">16.6.</span> <span class="nav-text">实例变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Collection-Methods"><span class="nav-number">17.</span> <span class="nav-text">Defining Collection Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义容器方法"><span class="nav-number">18.</span> <span class="nav-text">定义容器方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Indexed-Collections"><span class="nav-number">18.1.</span> <span class="nav-text">Accessing Indexed Collections</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器索引访问器"><span class="nav-number">18.2.</span> <span class="nav-text">容器索引访问器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Indexed-Collection-Getters"><span class="nav-number">18.2.1.</span> <span class="nav-text">Indexed Collection Getters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器索引获取方法"><span class="nav-number">18.2.2.</span> <span class="nav-text">容器索引获取方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Indexed-Collection-Mutators"><span class="nav-number">18.2.3.</span> <span class="nav-text">Indexed Collection Mutators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引容器修改器"><span class="nav-number">18.2.4.</span> <span class="nav-text">索引容器修改器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Unordered-Collections"><span class="nav-number">18.3.</span> <span class="nav-text">Accessing Unordered Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unordered-Collection-Getters"><span class="nav-number">18.3.1.</span> <span class="nav-text">Unordered Collection Getters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无序容器获取方法"><span class="nav-number">18.3.2.</span> <span class="nav-text">无序容器获取方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unordered-Collection-Mutators"><span class="nav-number">18.3.3.</span> <span class="nav-text">Unordered Collection Mutators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无序集合修改器"><span class="nav-number">18.3.4.</span> <span class="nav-text">无序集合修改器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-Non-Object-Values"><span class="nav-number">19.</span> <span class="nav-text">Handling Non-Object Values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理非对象值"><span class="nav-number">20.</span> <span class="nav-text">处理非对象值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Adding-Validation"><span class="nav-number">21.</span> <span class="nav-text">Adding Validation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加校验"><span class="nav-number">22.</span> <span class="nav-text">添加校验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-a-Validation-Method"><span class="nav-number">22.1.</span> <span class="nav-text">Implementing a Validation Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现一个校验方法"><span class="nav-number">22.2.</span> <span class="nav-text">实现一个校验方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Validation-of-Scalar-Values"><span class="nav-number">22.3.</span> <span class="nav-text">Validation of Scalar Values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#校验基本数据类型值"><span class="nav-number">22.4.</span> <span class="nav-text">校验基本数据类型值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Describing-Property-Relationships"><span class="nav-number">23.</span> <span class="nav-text">Describing Property Relationships</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#描述属性关系"><span class="nav-number">24.</span> <span class="nav-text">描述属性关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-Descriptions"><span class="nav-number">24.1.</span> <span class="nav-text">Class Descriptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类描述"><span class="nav-number">24.2.</span> <span class="nav-text">类描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Designing-for-Performance"><span class="nav-number">25.</span> <span class="nav-text">Designing for Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能设计"><span class="nav-number">26.</span> <span class="nav-text">性能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overriding-Key-Value-Coding-Methods"><span class="nav-number">26.1.</span> <span class="nav-text">Overriding Key-Value Coding Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写-KVC-方法"><span class="nav-number">26.2.</span> <span class="nav-text">重写 KVC 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-To-Many-Relationships"><span class="nav-number">26.3.</span> <span class="nav-text">Optimizing To-Many Relationships</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化多对多关系"><span class="nav-number">26.4.</span> <span class="nav-text">优化多对多关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compliance-Checklist"><span class="nav-number">27.</span> <span class="nav-text">Compliance Checklist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规范性清单"><span class="nav-number">28.</span> <span class="nav-text">规范性清单</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute-and-To-One-Relationship-Compliance"><span class="nav-number">28.1.</span> <span class="nav-text">Attribute and To-One Relationship Compliance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性和一对一关系规范"><span class="nav-number">28.2.</span> <span class="nav-text">属性和一对一关系规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Indexed-To-Many-Relationship-Compliance"><span class="nav-number">28.3.</span> <span class="nav-text">Indexed To-Many Relationship Compliance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引多对多关系规范性"><span class="nav-number">28.4.</span> <span class="nav-text">索引多对多关系规范性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unordered-To-Many-Relationship-Compliance"><span class="nav-number">28.5.</span> <span class="nav-text">Unordered To-Many Relationship Compliance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无序多对多关系规范性"><span class="nav-number">28.6.</span> <span class="nav-text">无序多对多关系规范性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Validation"><span class="nav-number">28.7.</span> <span class="nav-text">Validation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">28.8.</span> <span class="nav-text">验证</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jcapp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>

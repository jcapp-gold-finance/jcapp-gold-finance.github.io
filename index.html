<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="金诚App团队blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="金诚App团队blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="金诚App团队blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 金诚App团队blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">金诚App团队blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/UIFeedbackGenerator/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/25/UIFeedbackGenerator/" itemprop="url">
                  UIFeedbackGenerator 翻译一篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T10:00:00+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Interpreter：戴奕</p>
<p>iPhone 7 之后的机型中，苹果使用了最新的 Taptic Engine 震动引擎，该引擎能够模拟不同的振感，因此系统在人机交互上达到了一个新的顶端。当然该功能同样以 API 形式开放给了 iOS 开发人员，本篇文章是对 UIFeedbackGenerator API 以及相关 人机交互指南的翻译。</p>
</blockquote>
<p>Class</p>
<h2 id="UIFeedbackGenerator"><a href="#UIFeedbackGenerator" class="headerlink" title="UIFeedbackGenerator"></a>UIFeedbackGenerator</h2><p>The abstract superclass for all feedback generators.</p>
<p>该类是所有反馈产生器的抽象类.</p>
<h2 id="Overview（概览）"><a href="#Overview（概览）" class="headerlink" title="Overview（概览）"></a>Overview（概览）</h2><p>Do not subclass or create instances of this class yourself. Instead, instantiate one of the provided concrete subclasses:</p>
<p><a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIImpactFeedbackGenerator</code></a>. Use impact feedback generators to indicate that an impact has occurred. For example, you might trigger impact feedback when a user interface object collides with something or snaps into place.</p>
<p><a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UISelectionFeedbackGenerator</code></a>. Use selection feedback generators to indicate a change in selection.</p>
<p><a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UINotificationFeedbackGenerator</code></a>. Use notification feedback generators to indicate successes, failures, and warnings.</p>
<p>不要自己创建该类的实例或者子类。你应该使用已经提供的子类：</p>
<p><a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIImpactFeedbackGenerator</code></a>. 使用碰撞反馈发生器来表明发生了碰撞。举个例子，当用户界面上的一个对象碰到什么东西、或者卡到某个地方的时候，触发碰撞反馈发生器。</p>
<p><a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UISelectionFeedbackGenerator</code></a>. 使用选择反馈发生器来表明选择状态发生了改变。</p>
<p><a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UINotificationFeedbackGenerator</code></a>. 使用通知反馈发生器来表明成功，失败，警告。</p>
<h3 id="Using-Feedback-Generators"><a href="#Using-Feedback-Generators" class="headerlink" title="Using Feedback Generators"></a>Using Feedback Generators</h3><p>Haptic feedback provides a tactile response, such as a tap, that draws attention and reinforces both actions and events. While many system-provided interface elements (for example, pickers, switches, and sliders) automatically provide haptic feedback, you can use feedback generators to add your own feedback to custom views and controls.</p>
<p>触觉反馈提供触觉响应，比如敲击，这会吸引用户的注意力并增强了行动和事件。许多系统提供的界面元素（例如选择器、开关、滑块）都提供了触觉反馈，你可以把反馈生成器添加到你自定义的视图和控件中。</p>
<blockquote>
<p> Tip</p>
<p> If you want to include sound along with the haptic feedback, you need to manually play the sound and sync it with the haptics.</p>
<p>提示</p>
<p>如果你想在触觉反馈的同时播放声音，你需要手动播放声音并与触觉同步。</p>
</blockquote>
<p>When providing feedback:</p>
<ul>
<li>Always use feedback for its intended purpose. Don’t select a haptic because of the way it feels.</li>
<li>The source of the feedback must be clear to the user. For example, the feedback must match a visual change in the user interface, or must be in response to a user action. Feedback should never come as a surprise.</li>
<li>Don’t overuse feedback. Overuse can cause confusion and diminish the feedback’s significance.</li>
</ul>
<p>当你提供反馈时：</p>
<ul>
<li>把反馈用在该用的地方上。不要因为触觉反馈而使用触觉反馈。</li>
<li>必须让用户清除反馈的来源。举个例子，触觉反馈必须和视觉的改变匹配，或者必须是响应用户的操作。不要把反馈当做“惊喜”给用户。</li>
<li>不要过度使用反馈。过度使用会变得混乱并会减少反馈的意义。</li>
</ul>
<p>For additional guidance on when and how to use feedback generators, see <a href="https://developer.apple.com/ios/human-interface-guidelines/interaction/feedback/#haptics" target="_blank" rel="external">Haptic Feedback</a> in <a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="external">iOS Human Interface Guidelines</a>.</p>
<p>有关如何使用反馈发生器的更多指导，请查看 <a href="https://developer.apple.com/ios/human-interface-guidelines/interaction/feedback/#haptics" target="_blank" rel="external">Haptic Feedback</a> in <a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="external">iOS Human Interface Guidelines</a>。</p>
<p>To use a feedback generator, the following are required:</p>
<ol>
<li><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555404" target="_blank" rel="external">Instantiating the Generator</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555405" target="_blank" rel="external">Preparing the Generator</a> (optional)</li>
<li><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555415" target="_blank" rel="external">Triggering Feedback</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555460" target="_blank" rel="external">Releasing the Generator</a> (optional).</li>
</ol>
<p>要使用反馈发生器，下列几点是必须的：</p>
<ol>
<li>初始化发生器</li>
<li>准备好发生器（可选）</li>
<li>触发发生器</li>
<li>释放发生器（可选）</li>
</ol>
<p>Listing 1 demonstrates triggering selection feedback from a pan gesture recognizer.</p>
<p><strong>Listing 1</strong> Triggering selection feedback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (IBAction)gestureHandler:(UIPanGestureRecognizer *)sender &#123;</div><div class="line">    </div><div class="line">    switch (sender.state) &#123;</div><div class="line">        case UIGestureRecognizerStateBegan:</div><div class="line">            </div><div class="line">            // Instantiate a new generator.</div><div class="line">            self.feedbackGenerator = [[UISelectionFeedbackGenerator alloc] init];</div><div class="line">            </div><div class="line">            // Prepare the generator when the gesture begins.</div><div class="line">            [self.feedbackGenerator prepare];</div><div class="line">            </div><div class="line">            break;</div><div class="line">            </div><div class="line">        case UIGestureRecognizerStateChanged:</div><div class="line">            </div><div class="line">            // Check to see if the selection has changed...</div><div class="line">            if ([self myCustomHasSelectionChangedMethodWithTranslation:[sender translationInView: self.view]]) &#123;</div><div class="line">                </div><div class="line">                // Trigger selection feedback.</div><div class="line">                [self.feedbackGenerator selectionChanged];</div><div class="line">                </div><div class="line">                // Keep the generator in a prepared state.</div><div class="line">                [self.feedbackGenerator prepare];</div><div class="line">    </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">            </div><div class="line">        case UIGestureRecognizerStateCancelled:</div><div class="line">        case UIGestureRecognizerStateEnded:</div><div class="line">        case UIGestureRecognizerStateFailed:</div><div class="line">            </div><div class="line">            // Release the current generator.</div><div class="line">            self.feedbackGenerator = nil;</div><div class="line">            </div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            </div><div class="line">            // Do nothing.</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Instantiating-the-Generator"><a href="#Instantiating-the-Generator" class="headerlink" title="Instantiating the Generator"></a>Instantiating the Generator</h4><p>To create feedback, you must first instantiate one of the <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIFeedbackGenerator</code></a> class’s concrete subclasses (<a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIImpactFeedbackGenerator</code></a>, <a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UISelectionFeedbackGenerator</code></a>, or <a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UINotificationFeedbackGenerator</code></a>).</p>
<p><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2576673" target="_blank" rel="external">Listing 1</a> instantiates a new <a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UISelectionFeedbackGenerator</code></a> object whenever a pan gesture begins.</p>
<p>如果要创建一个反馈，首先你必须从指定的 <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIFeedbackGenerator</code></a>子类中创建。</p>
<p>清单1是在移动手势开始时创建了一个<a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator?language=objc" target="_blank" rel="external"><code>UISelectionFeedbackGenerator</code></a> 实例。</p>
<h4 id="Preparing-the-Generator"><a href="#Preparing-the-Generator" class="headerlink" title="Preparing the Generator"></a>Preparing the Generator</h4><p>Preparing the generator can reduce latency when triggering feedback. This is particularly important when trying to match feedback to sound or visual cues.</p>
<p>Calling the generator’s <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a> method puts the Taptic Engine in a prepared state. To preserve power, the Taptic Engine stays in this state for only a short period of time (on the order of seconds), or until you next trigger feedback.</p>
<p>Think about when and where you can best prepare your generators. If you call <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a> and then immediately trigger feedback, the system won’t have enough time to get the Taptic Engine into the prepared state, and you may not see a reduction in latency. On the other hand, if you call <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a> too early, the Taptic Engine may become idle again before you trigger feedback.</p>
<p><a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2576673" target="_blank" rel="external">Listing 1</a> prepares the generator when the pan gesture begins, and then triggers feedback when the gesture changes.</p>
<p>For more information, see the <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a> method.</p>
<p>让发生器做好准备可以减少触发时的延迟。这点在与声音、视觉匹配时尤其重要。</p>
<p>调用<a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a>让Taptic引擎处于准备状态。为了节约电量，Taptic引擎只会在短时间内保持此状态（数秒），或者直到下一次触发反馈。</p>
<p>想清楚什么时候，在哪里准备发生器是最好的。如果你调用了<a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a>然后马上触发反馈，系统可能来不及让Taptic引擎进入准备状态，所以你可能看不到延迟的减少。另一方面，如果你调用<a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a>的实际太早，那么Taptic引擎可能在你触发反馈之前又恢复了闲置状态。</p>
<p>清单1是在手势开始时准备好发生器，然后在手势位置改变时触发反馈。</p>
<p>要获取更多的信息，查阅<a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a>方法。</p>
<h4 id="Triggering-Feedback"><a href="#Triggering-Feedback" class="headerlink" title="Triggering Feedback"></a>Triggering Feedback</h4><p>Each feedback generator subclass has a unique triggering method. To trigger feedback, call the appropriate method: <a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator/2374287-impactoccurred?language=objc" target="_blank" rel="external"><code>impactOccurred</code></a>, <a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator/2374284-selectionchanged?language=objc" target="_blank" rel="external"><code>selectionChanged</code></a>, or <a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator/2369826-notificationoccurred?language=objc" target="_blank" rel="external"><code>notificationOccurred:</code></a>.</p>
<p>Note that calling these methods does not play haptics directly. Instead, it informs the system of the event. The system then determines whether to play the haptics based on the device, the application’s state, the amount of battery power remaining, and other factors.</p>
<p>For example, haptic feedback is currently played only:</p>
<ul>
<li>On a device with a supported Taptic Engine (iPhone 7 and iPhone 7 Plus).</li>
<li>When the app is running in the foreground.</li>
<li>When the System Haptics setting is enabled.</li>
</ul>
<p>As a general rule, trust the system to determine whether it should play feedback. Don’t check the device type or app state to conditionally trigger feedback. After you’ve decided how you want to use feedback, always trigger it when the appropriate events occur. The system ignores any requests that it cannot fulfill.</p>
<p>In <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2576673" target="_blank" rel="external">Listing 1</a>, each time the gesture changes the gesture handler checks to see if the selection has changed. If so, the handler triggers feedback and prepares for the next change.</p>
<p>每一个发生器的子类都有自己独特的触发方法。去触发反馈，去调用适当的方法：<a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator/2374287-impactoccurred?language=objc" target="_blank" rel="external"><code>impactOccurred</code></a>, <a href="https://developer.apple.com/reference/uikit/uiselectionfeedbackgenerator/2374284-selectionchanged?language=objc" target="_blank" rel="external"><code>selectionChanged</code></a>, or <a href="https://developer.apple.com/reference/uikit/uinotificationfeedbackgenerator/2369826-notificationoccurred?language=objc" target="_blank" rel="external"><code>notificationOccurred:</code></a>。</p>
<p>请注意，调用这些方法不会立即触发触觉反馈。而是把该事件通知系统。系统会根据设备、应用程序状态、剩余电量以及其他因素类决定是否播放触觉。</p>
<p>举个例子，只有在以下几个情况触觉反馈会立即触发：</p>
<ul>
<li>在一个支持Taptic Engine的设备上（iPhone 7 and iPhone 7 Plus）。</li>
<li>应用程序在前台运行。</li>
<li>设置-&gt;声音与触觉-&gt;系统触觉反馈 选项打开。</li>
</ul>
<p>作为一般规则，应该信任系统来决定是否播放反馈。不要在触发反馈之前检查设备类型与应用的状态。当你决定好想如何使用反馈，那么在合适的事件发生时都要去触发反馈（而不用去判断）。系统会忽略任何不能满足的请求。</p>
<p>在清单1中，任何时候当手势位置改变时都会去检查选中状态。如果是选中，那么就会触发反馈并且会为下一次改变将发生器置为准备状态。</p>
<h4 id="Releasing-the-Generator"><a href="#Releasing-the-Generator" class="headerlink" title="Releasing the Generator"></a>Releasing the Generator</h4><p>If you no longer need a prepared generator, remove all references to the generator object and let the system deallocate it. This lets the Taptic Engine return to its idle state.</p>
<p>In <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2576673" target="_blank" rel="external">Listing 1</a>, the pan gesture recognizer releases its generator when the gesture ends, fails, or is canceled. Assigning <code>nil</code> to the instance variable removes the reference to the old generator. If there are no other references to the generator, the system deallocates it.</p>
<p>如果你不再需要准备发生器，那么把该对象所有的引用移除掉，让系统释放该对象。这会让Taptic引擎回到闲置状态。</p>
<p>在清单1中，在手势对象结束/失败/取消时都会释放发生器。设置会nil会移除对旧发生器的引用。如果没有别的引用了，系统就会销毁这个对象。</p>
<p>Instance Method</p>
<h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><p>Prepares the generator to trigger feedback.</p>
<p>发生器置为触发做准备 </p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>When you call this method, the generator is placed into a prepared state for a short period of time. While the generator is prepared, you can trigger feedback with lower latency.</p>
<p>Think about when you can best prepare your generators. Call <code>prepare</code> before the event that triggers feedback. The system needs time to prepare the Taptic Engine for minimal latency. Calling <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator/2369818-prepare?language=objc" target="_blank" rel="external"><code>prepare</code></a> and then immediately triggering feedback (without any time in between) does not improve latency.</p>
<p>To conserve power, the Taptic Engine returns to an idle state after any of the following events:</p>
<ul>
<li>You trigger feedback on the generator.</li>
<li>A short period of time passes (typically seconds).</li>
<li>The generator is deallocated.</li>
</ul>
<p>After feedback is triggered, the Taptic Engine returns to its idle state. If you might trigger additional feedback within the next few seconds, immediately call <code>prepare</code> to keep the Taptic Engine in the prepared state.</p>
<p>You can also extend the prepared state by repeatedly calling the <code>prepare</code> method. However, if you continue calling <code>prepare</code> without ever triggering feedback, the system may eventually place the Taptic Engine back in an idle state and ignore any further <code>prepare</code> calls until after you trigger feedback at least once.</p>
<p>If you no longer need a prepared generator, remove all references to the generator object and let the system deallocate it. This lets the Taptic Engine return to its idle state.</p>
<p>当你调用这个方法，发生器会在短时间内置为准备状态。在准备状态期间触发的话会降低延迟。</p>
<p>想清楚在最合适的实际去准备发生器。在触发反馈之前调用<code>prepare</code> 方法。系统为了降低延迟需要一些时间去准备Taptic引擎。调用<code>prepare</code> 方法然后立即触发并不会立即降低延迟（没有任何时间间隔）。</p>
<p>为了节约电量，Taptic引擎会在下列几种情况下回到闲置状态：</p>
<ul>
<li>触发了反馈。</li>
<li>过去了一小段时间（一般为几秒）。</li>
<li>发生器销毁了。</li>
</ul>
<p>在触发过后，Taptic引擎会回到闲置状态。如果你在接下来的几秒钟可能再次触发反馈，那么久立即调用<code>prepare</code>方法来让Taptic引擎进入准备状态。</p>
<p>你还可以通过反复调用<code>prepare</code>方法来延长准备状态。然而，如果你一直没有触发反馈，但还是继续调用<code>prepare</code>方法，那么系统会将Taptic引擎置为闲置状态，并且忽视你的<code>prepare</code>方法，除非你触发一次反馈。</p>
<p>如果你再也不需要准备一个发生器，移除所有的引用让系统销毁它。这会让Taptic引擎置为闲置状态。</p>
<blockquote>
<p>Note</p>
<p>The <code>prepare</code> method is optional; however, it is highly recommended. Calling this method helps ensure that your feedback has the lowest possible latency.</p>
<p>注意点</p>
<p><code>prepare</code>是可选的，但是是极力推荐的。调用这个方法有助于确保反馈的及时性。</p>
</blockquote>
<p>Class</p>
<h2 id="UIImpactFeedbackGenerator"><a href="#UIImpactFeedbackGenerator" class="headerlink" title="UIImpactFeedbackGenerator"></a>UIImpactFeedbackGenerator</h2><p>A concrete <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIFeedbackGenerator</code></a> subclass that creates haptics to simulate physical impacts.</p>
<p>一个用来创建模拟物理碰撞触觉的 <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator?language=objc" target="_blank" rel="external"><code>UIFeedbackGenerator</code></a>具体子类。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Use impact feedback to indicate that an impact has occurred. For example, you might trigger impact feedback when a user interface object collides with another object or snaps into place.</p>
<p>For more information, see <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555399" target="_blank" rel="external">Using Feedback Generators</a>.</p>
<p>使用碰撞反馈来表明发生了一个碰撞。举个例子，当用户界面上的一个对象碰到什么东西、或者卡到某个地方的时候，触发碰撞反馈发生器。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><h3 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h3><p><a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackgenerator/2374286-initwithstyle?language=objc" target="_blank" rel="external"><code>- initWithStyle:</code></a>Returns a newly initialized feedback generator.</p>
<p>Instance Method</p>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><ul>
<li><p><code>style</code></p>
<p>A value representing the mass of the colliding objects. For a list of valid feedback styles, see the <a href="https://developer.apple.com/reference/uikit/uiimpactfeedbackstyle?language=objc" target="_blank" rel="external"><code>UIImpactFeedbackStyle</code></a> enumeration.</p>
<p>一个代表碰撞对象的质量的值。</p>
</li>
</ul>
<h2 id="iOS-Human-Interface-Guidelines"><a href="#iOS-Human-Interface-Guidelines" class="headerlink" title="iOS Human Interface Guidelines"></a>iOS Human Interface Guidelines</h2><h2 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h2><p>Feedback helps people know what an app is doing, discover what they can do next, and understand the results of actions.</p>
<p>反馈帮助人们知道应用现在在做什么，知道接下来该做什么，理解事件的结果。</p>
<p><strong>Unobtrusively integrate status and other types of feedback into your interface.</strong> Ideally, users can get important information without taking action or being interrupted. Mail, for example, subtly displays status information in the toolbar while navigating through mailboxes of messages. This information doesn’t compete with the primary content onscreen, but can be checked at any time with a quick glance.</p>
<p><strong>将状态与其他类型的反馈不间断地集成到你的界面中。</strong>理想情况下，用户可以再不中断动作的情况下获取重要信息。例如，“邮箱”在导航邮件时，巧妙地将当前的状态信息显示在（下方）工具栏中。这个内容不会喧宾夺主，但是可以快速地获取相关信息。</p>
<p><strong>Avoid unnecessary alerts.</strong> An alert is a powerful feedback mechanism, but should be used only to deliver important—and ideally actionable—information. If people see too many alerts that don’t contain essential information, they quickly learn to ignore future alerts. For additional guidance, see <a href="https://developer.apple.com/ios/human-interface-guidelines/ui-views/alerts/" target="_blank" rel="external">Alerts</a>.</p>
<p><strong>避免不必要的弹框。</strong>弹框是一种强有力的反馈手段，但是只能够在传递重要信息以及理想的信息时进行使用。如果人们经常看到没有必要信息的弹框，他们很快就会学会忽略弹框。要获取更多信息，请查阅 <a href="https://developer.apple.com/ios/human-interface-guidelines/ui-views/alerts/" target="_blank" rel="external">Alerts</a>.</p>
<h3 id="Haptic-Feedback"><a href="#Haptic-Feedback" class="headerlink" title="Haptic Feedback"></a>Haptic Feedback</h3><p>On supported devices, haptics provide a way to physically engage users with tactile feedback that gets attention and reinforces actions. Some system-provided interface elements, such as pickers, switches, and sliders, automatically provide haptic feedback as users interact with them. Your app can also ask the system to generate different types of haptic feedback. iOS manages the strength and behavior of this feedback.</p>
<p>在支持的设备上，触觉提供了一种可以吸引用户注意力并加强重视的一种反馈方式。一些系统控件已经提供了这种功能，例如选择器、开关、进度滑竿等，在用户使用这些控件交互时会自动提供触觉反馈。你的应用程序也可以要求系统产生不同类型的触觉反馈。iOS系统会管理这种反馈的强度和行为。</p>
<h5 id="Notification（通知）"><a href="#Notification（通知）" class="headerlink" title="Notification（通知）"></a>Notification（通知）</h5><ul>
<li>Success：指示任务或动作，例如存入支票、解锁车辆等已经完成</li>
<li>Warning：表示任务或动作，例如存入支票、解锁车辆等，发出某种警告</li>
<li>Failure：表示任务或动作，例如存入支票、解锁车辆等，已经失败</li>
</ul>
<h5 id="Impact（影响）"><a href="#Impact（影响）" class="headerlink" title="Impact（影响）"></a>Impact（影响）</h5><ul>
<li>Light：提供一个给视觉补充的触觉反应。例如，当一个视图滑入或者两个物体碰撞时，用户会觉得砰的一声</li>
<li>Medium：同上</li>
<li>Heavy：同上</li>
</ul>
<h5 id="Selection（选择）"><a href="#Selection（选择）" class="headerlink" title="Selection（选择）"></a>Selection（选择）</h5><ul>
<li>Selection：当一个选择器正在改变时提供提示。例如，当滚动一个选择器时，用户会感觉到轻轻的敲击声。这种反馈旨在通过一系列离散值来传递运动，而不是制定或确认一个选择。</li>
</ul>
<p><strong>Use haptics judiciously.</strong> Overuse can cause confusion and diminish the significance of feedback.</p>
<p>明智地使用触觉反馈。过度使用会导致混乱，削弱反馈的重要性。</p>
<p><strong>In general, provide haptic feedback in response to user-initiated actions.</strong> It’s easy for people to correlate haptics with actions they initiated. Arbitrary feedback can feel disconnected and be misinterpreted.</p>
<p>一般来说，在用户发起的动作时提供触觉反馈。人们很容易将他们的动作与触觉关联在一起。随意的触觉反馈会导致误解和没有联系。</p>
<p><strong>Don’t redefine feedback types.</strong> To ensure a consistent experience, use feedback types as intended. Don’t, for example, use “impact” feedback to notify the user that a task has succeeded. Instead, use the “success” variation of “notification” feedback.</p>
<p>不要重新第一反馈类型。为了保持体验的一致性，请使用预期的反馈类型。例如不要使用 “impact” 充当一个任务完成的反馈，应该使用 “notification” 。</p>
<p><strong>Fine tune your visual experience for haptics.</strong> Provide visual and haptic feedback together to create a deeper connection between actions and results. Make sure animations are sharp and precise, to visually match what the user feels.</p>
<p>协调你的触觉、视觉体验。一起使用视觉、触觉反馈来加强动作和结果之间的联系。视觉上确保动画清晰和精确以匹配用户的感受。</p>
<p><strong>Don’t rely on a single mode of communication.</strong> Not all devices support the full range of haptic feedback, and people can disable the feature entirely in Settings if they choose. In addition, haptic feedback occurs only when the device is active and your app is frontmost. Supplement haptics with visual and audible cues to ensure that important information isn’t missed.</p>
<p>不要依赖于一种单一的沟通方式。不是所有的设备都支持全方位的触觉反馈，同时用户可以再设置中选择禁用这项特性。另外，触觉反馈只有在你的设备是开启状态并且你的应用是处于前台。视觉中补充触觉反馈以确保重要的信息不被错过。</p>
<p><strong>Use haptics when visual feedback may be occluded.</strong> Some interactions, such as dragging an object to a location onscreen, are hidden by the user’s finger. Consider generating feedback that lets the user know when they’ve reached a particular location or value.</p>
<p>当视觉反馈可能被遮挡时，使用触觉反馈。一些交互，如将对象拖动到屏幕上的位置，会被用户的手指所遮挡。考虑使用触觉反馈来告诉用户到达了指定位置或者值。</p>
<p><strong>Prepare the system before initiating feedback.</strong> Because there may be some latency involved when providing haptic feedback, it’s best to get the system ready shortly before requesting the feedback. Otherwise, the haptics might come too late and feel disconnected from the user’s actions or what they’re seeing on the screen.</p>
<p>在启动反馈之前让系统做准备。因为在提供触觉反馈时可能会有一些延迟，所以最好在请求反馈之前尽快准备好系统。否则发生触觉时可能太迟了，会导致用户无法将当前屏幕上的动作和反馈联系起来。</p>
<p><strong>Synchronize haptics with accompanying sound.</strong> Haptics don’t automatically synchronize with sounds. If you want an accompanying sound, you’re responsible for synchronizing it.</p>
<p>将触觉与声音同步。触觉不会自动同步声音。如果你想要同步发出声音，你需要负责同步这个事情。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/Apple Scheme URL Reference/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/Apple Scheme URL Reference/" itemprop="url">
                  About Apple URL Schemes 翻译一篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T11:20:25+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>Interpreter：戴奕</p>
<p>Apple 官方文档：《Apple Scheme URL Reference》翻译一篇。文虽短但里面还是有些有意思的东西。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/12/14/Apple Scheme URL Reference/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/XcodeDebug/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/21/XcodeDebug/" itemprop="url">
                  Xcode断点实用调试技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T14:45:12+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：王振华</p>
</blockquote>
<h1 id="Xcode断点实用调试技巧"><a href="#Xcode断点实用调试技巧" class="headerlink" title="Xcode断点实用调试技巧"></a>Xcode断点实用调试技巧</h1><p>断点是iOS开发中最常用的调试技巧，Xcode的断点功能是非常强大的，下面介绍一些常用的技巧。</p>
<h2 id="编辑断点"><a href="#编辑断点" class="headerlink" title="编辑断点"></a>编辑断点</h2><p>为了测试，我们先写一个简单的demo。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">// insert code here...</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后可以在for循环内加一个断点，并选择Edit Breakpoint。<br><img src="/img/XcodeDebug/XcodeDebug1.png" alt="1"></p>
<p>我们可以设置断点执行的condition，这里设置i==5。<br><img src="/img/XcodeDebug/XcodeDebug4.png" alt="4"><br><img src="/img/XcodeDebug/XcodeDebug3.png" alt="3"><br>可以看到，当运行到i==5时，断点被触发。<br>另外，也可以在ignore中选择忽略若干次循环。</p>
<p>action表示触发断点时执行的操作，这里的功能非常强大，除了常见的输出log信息，还可以播放声音，甚至运行脚本。<br><img src="/img/XcodeDebug/XcodeDebug7.png" alt="7"></p>
<p>在这里，我们选择忽略前两次循环，并打印i的值。<br><img src="/img/XcodeDebug/XcodeDebug2.png" alt="2"></p>
<p>可以看到输出结果。<br><img src="/img/XcodeDebug/XcodeDebug5.png" alt="5"></p>
<p>勾选option，可以在断点触发之后继续运行程序。</p>
<h2 id="异常捕获断点"><a href="#异常捕获断点" class="headerlink" title="异常捕获断点"></a>异常捕获断点</h2><p>当程序crash时，我们希望能准确定位到错误位置。但是Xcode有时并不能准确捕获，而是断在main函数里。这时可以增加一个全局的Exception Breakpoint。大多数异常都可以用这种方法捕获。<br><img src="/img/XcodeDebug/XcodeDebug6.png" alt="6"></p>
<h2 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点"></a>符号断点</h2><p>Symbolic Breakpoint也是一个全局断点，在断点的描述里可以设置Symbol（方法名）、Module（模块名）、Condition、Action等。例如，想在代码中查找是否有图片为nil，可以这样设置。arg3表示第一个参数，arg4表示第二个参数。<br><img src="/img/XcodeDebug/XcodeDebug8.png" alt="8"></p>
<p>当程序运行到有图片被设为nil时，就会触发断点。<br><img src="/img/XcodeDebug/XcodeDebug9.png" alt="9"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/iOS-socket/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/iOS-socket/" itemprop="url">
                  iOS 基于GCDAsyncSocket实现的即时聊天
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T16:20:25+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：费宇超</p>
</blockquote>
<p>本文不讨论技术选型，不介绍业务逻辑。<br>简单地介绍下开发中会遇到的一些技术点，解决的一些方案。</p>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>因为是基于TCP的，而TCP的是流式传输的，不像UDP数据报传输是有边界的，所以会有粘包问题。<br>然而这个问题是必须解决的，大致有三种方法。</p>
<p>1：固定包的长度，每次读数据的时候，固定读取字节。这在实际使用中基本不现实。</p>
<p>2：服务器每次发送消息的时候，给每个包添加上分隔符,如/r,/n。GCDAsyncSocket也有方法按照此逻辑直接切割。但这个方案也非常不靠谱。</p>
<p>3：一般的处理方法是定义一个消息头，消息头中包含了一个包的长度，先拿到包长度再去读取完整的包。</p>
<h3 id="Socket通信定义"><a href="#Socket通信定义" class="headerlink" title="Socket通信定义"></a>Socket通信定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">头信息：2字节 版本号</div><div class="line">功能代码：2字节  功能代码</div><div class="line">是否压缩：1个字节 0不压缩， 1压缩</div><div class="line">消息长度：2字节</div><div class="line">消息实体：</div></pre></td></tr></table></figure>
<p>功能代码是指消息的类型，定义了许多许多， 因为每个项目定义都不一样，就不介绍了。<br>按照我们的通信定义，我是这么处理粘包的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    //解决粘包</div><div class="line">    //思路是拆分包头得到长度,判断接得到的长度和包头的长度是否一致，不够就继续拼接，相等就返回，大于的话就自己做下拆分。先</div><div class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123;</div><div class="line">    if (tag == 0) &#123;</div><div class="line">        self.readBufferData = [data mutableCopy];</div><div class="line">         unsigned short dataLength;</div><div class="line">        if(data.length &gt;= 7)&#123;</div><div class="line">            dataLength = [self getDataLength:data];</div><div class="line">        &#125;else&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        [self.socketManager.socket readDataToLength:dataLength withTimeout:-1 tag:1];</div><div class="line">    &#125;else if(tag == 1)&#123;</div><div class="line">        NSMutableData * completeData = self.readBufferData;</div><div class="line">        self.readBufferData = nil;</div><div class="line">        [completeData appendData:data];</div><div class="line">        [self handleData:completeData];</div><div class="line">        [self.socketManager.socket readDataToLength:7 withTimeout:-1 tag:0];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单解释下，上面的代理方法是GCDAsyncSocket读取数据方法，tag可以区分我的读数据请求，如上tag==0 是我发起的读消息头的返回，再用消息头中的字节长度去读完整的包，即tag==1的返回。</p>
<p>乍看一下似乎没有问题了，我也是这么以为的。同事之前写过量级比较大的通信，他遇到过问题，因为网卡缓冲区有个最大值，MTU，如果一下子来N多消息，字节会溢出，有可能会导致字节的少读多读。所以要严格按照代码以上的注释写代码，时间有限，我这边先不上代码。</p>
<h2 id="生成数据报和解数据报"><a href="#生成数据报和解数据报" class="headerlink" title="生成数据报和解数据报"></a>生成数据报和解数据报</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dataLength = [self getDataLength:data];</div></pre></td></tr></table></figure>
<p>上面的代码有这样一个方法。按照字节去拿数据。之前不太清楚苹果有API可以调用。自己写了2个压缩字节的，估计还有些问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/** 将数值转成字节。编码方式：低位在前，高位在后 */</div><div class="line">- (NSData *)bytesFromValue:(NSInteger)value byteCount:(int)byteCount</div><div class="line">&#123;</div><div class="line">    NSAssert(value &lt;= 4294967295, @&quot;bytesFromValue: (max value is 4294967295)&quot;);</div><div class="line">    NSAssert(byteCount &lt;= 4, @&quot;bytesFromValue: (byte count is too long)&quot;);</div><div class="line">    </div><div class="line">    NSMutableData *valData = [[NSMutableData alloc] init];</div><div class="line">    NSUInteger tempVal = value;</div><div class="line">    int offset = 0;</div><div class="line">    </div><div class="line">    while (offset &lt; byteCount) &#123;</div><div class="line">        unsigned char valChar = 0xff &amp; tempVal;</div><div class="line">        [valData appendBytes:&amp;valChar length:1];</div><div class="line">        tempVal = tempVal &gt;&gt; 8;</div><div class="line">        offset++;</div><div class="line">    &#125;//while</div><div class="line">    </div><div class="line">    return [self dataWithReverse:valData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="正确的做法如下"><a href="#正确的做法如下" class="headerlink" title="正确的做法如下"></a>正确的做法如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  生成数据报model</div><div class="line"> */</div><div class="line"></div><div class="line">-(NSData *)socketModelToData&#123;</div><div class="line">    NSString * bodyString = @&quot;&quot;;</div><div class="line">    if([self.body isKindOfClass:[NSDictionary class]])&#123;</div><div class="line">        bodyString = [self dictionnaryObjectToString:self.body];</div><div class="line">    &#125;</div><div class="line">    NSData * dataBody = [bodyString dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    unsigned short bVersion = htons((short)self.version);</div><div class="line">    NSMutableData *version = [[NSMutableData alloc] initWithBytes:&amp;bVersion length:2];</div><div class="line">    </div><div class="line">    unsigned short vFunctionCode = htons((short)self.functionCode);</div><div class="line">    [version appendBytes:&amp;vFunctionCode length:2];</div><div class="line">    </div><div class="line">    unsigned short typeIsZip = htons((short)0);</div><div class="line">    [version appendBytes:&amp;typeIsZip length:1];</div><div class="line">    </div><div class="line">    unsigned short vDataBodyLength = htons((short)dataBody.length);</div><div class="line">    [version appendBytes:&amp;vDataBodyLength length:2];</div><div class="line">    [version appendData:dataBody];</div><div class="line"></div><div class="line">    return version;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  解析数据报model</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line">- (DXSocketModel *)dataToSocketModel:(NSData *)data&#123;</div><div class="line">    </div><div class="line">    DXSocketModel * socketModel = [[DXSocketModel alloc] init];</div><div class="line">    unsigned short  version;</div><div class="line">    unsigned short  functionCode;</div><div class="line">    unsigned short  isGzip;</div><div class="line">    unsigned short  dataLength;</div><div class="line">   </div><div class="line">    [data getBytes:&amp;version range:NSMakeRange(0,2)];</div><div class="line">    [data getBytes:&amp;functionCode range:NSMakeRange(2,2)];</div><div class="line">    [data getBytes:&amp;isGzip range:NSMakeRange(4,1)];</div><div class="line">    [data getBytes:&amp;dataLength range:NSMakeRange(5,2)];</div><div class="line"> </div><div class="line">    </div><div class="line">    socketModel.version = ntohs(version);</div><div class="line">    socketModel.functionCode = ntohs(functionCode);</div><div class="line">    socketModel.isGzip =  ntohs(isGzip);</div><div class="line">    socketModel.dataLength = ntohs(dataLength);</div><div class="line">    </div><div class="line">//   if(socketModel.dataLength + 7 == data.length)&#123;</div><div class="line">    NSData * jsonData =  [data subdataWithRange:NSMakeRange(7,socketModel.dataLength)];</div><div class="line">    NSString * jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</div><div class="line">    socketModel.body = [self dictionaryWithJsonString:jsonStr];</div><div class="line">//    &#125;else&#123;</div><div class="line">//        NSLog(@&quot;包头提示长度和实际长度不一样&quot;);</div><div class="line">//    &#125;</div><div class="line">    ;</div><div class="line">    return socketModel;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="网络字节序和主机字节序"><a href="#网络字节序和主机字节序" class="headerlink" title="网络字节序和主机字节序"></a>网络字节序和主机字节序</h2><p>如果你认真看了的话，你会发现生成数据和解析数据的时候，我用了这两个ntohs，htons函数，主要是生成的字节高低位和传输中的字节高低位不同。需要转换。</p>
<p>大端和小端（网络字节序和主机字节序）<br>大端（Big Endian）：即网络字节序。<br>小端（Littile Endian）：即主机字节序。<br>这里不得不感叹下API的丰富，方便了我们一批API调用者。<br><a href="http://blog.csdn.net/ce123_zhouwei/article/details/6971544" target="_blank" rel="external">详解大端模式和小端模式</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>至于一些比较基本的问题：心跳包、断线重连（断线重连要区分是自己主动断开还是网络异常）、GCDAsyncSocket的一些代理方法（GCDAsyncSockets是非阻塞的），百度太多见，就不重复介绍了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/iOS Crash 分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/iOS Crash 分析/" itemprop="url">
                  iOS Crash 分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T14:53:05+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：郭滚华</p>
</blockquote>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>应用崩溃影响用户体验，所以减少iOS应用奔溃是提高应用质量的重要途径。</p>
<h2 id="一、获取iOS应用-crash信息"><a href="#一、获取iOS应用-crash信息" class="headerlink" title="一、获取iOS应用 crash信息"></a>一、获取iOS应用 crash信息</h2><h3 id="1-通过itunes同步"><a href="#1-通过itunes同步" class="headerlink" title="1,通过itunes同步"></a>1,通过itunes同步</h3><ul>
<li>1，iOS设备上的应用闪退时, 操作系统会声称一个崩溃日志, 保存在设备上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">路径是:  设置 -&gt; 隐私 -&gt;诊断与用量 -&gt;诊断与用量数据。在这里可以看到设备上所有的设备崩溃日志.</div><div class="line">在“诊断与用量”界面，建议用户选择自动发送，这样可以每天自动发送诊断和用量数据到itunes，来帮助开发者分析崩溃.</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1290895-3d8b181cf40a9423.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>2，设备与电脑上的ITunes Store同步后, 会将崩溃日志保存在电脑上,崩溃日志保存在以下位置:  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mac OSX :~/Library/Logs/CrashReporter/MobileDevice/ </div><div class="line">可以看到所有和该电脑同步过的设备的崩溃日志(.crash文件)</div></pre></td></tr></table></figure>
<h3 id="2，使用Xcode"><a href="#2，使用Xcode" class="headerlink" title="2，使用Xcode"></a>2，使用Xcode</h3><ul>
<li><p>1，code的Window菜单下的organizer，然后点击Devices tab，然后选中左边的Device Logs。选中某一个崩溃日志，点击Export Log可导出崩溃日志(.crash文件)<br><img src="http://upload-images.jianshu.io/upload_images/1290895-886c9f44545ded5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>2,通过Xcode 获取appStore上架应用的crash信息。<br><img src="http://upload-images.jianshu.io/upload_images/1290895-cfe497d68d1279e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<h3 id="3，其他方式获取部分堆栈信息"><a href="#3，其他方式获取部分堆栈信息" class="headerlink" title="3，其他方式获取部分堆栈信息"></a>3，其他方式获取部分堆栈信息</h3><ul>
<li>1，通过代码获取应用的crash堆栈信息，然后下次启动时上传服务器获得日志信息。</li>
<li>2，通过友盟等第三方SDK拿到应用crash部分堆栈信息。<br>这种方式获取的应用信息都只有部分堆栈信息</li>
</ul>
<h2 id="二，获取应用的符号表"><a href="#二，获取应用的符号表" class="headerlink" title="二，获取应用的符号表"></a>二，获取应用的符号表</h2><h4 id="1，日志文件"><a href="#1，日志文件" class="headerlink" title="1，日志文件"></a>1，日志文件</h4><p>获取日志信息后，需要对堆栈调用信息分析<br><img src="http://upload-images.jianshu.io/upload_images/1290895-e416eb7ad0e83344.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>crash调用堆栈信息如图，有4列：第1列是栈顺序；第2列是二进制包名；第3列是运行地址；第四列是函数的动态加载地址，即加号前面的地址。</p>
<h4 id="2，dSYM文件"><a href="#2，dSYM文件" class="headerlink" title="2，dSYM文件"></a>2，dSYM文件</h4><p>在Xcode每次Archives的是都会生成dSYM文件，所有每次打包的时候的都需要保留包文件。点击.xcarchive文件，显示包含内容，在该目录下有生成的dSYM文件。dSYM文件也是Mach-o格式，Mach-O格式全称为Mach Object文件格式的缩写，是mac上可执行文件的格式，类似于windows上的PE格式 (Portable Executable ), Linux上的elf格式 (Executable and Linking Format)。<br>Mach-O可以分为3个部分</p>
<ul>
<li>(1)Header</li>
<li>(2)Segment</li>
<li>(3)section<br>header后面是segment，然后再跟着section，而一个segment是可以包含多个section的。MachOview工具可以可视化查看Mach-O文件格式，我们把dSYM文件放入可视化工具:<br><img src="http://upload-images.jianshu.io/upload_images/1290895-817730e6ff3cc19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>该dSYM文件包含armv7和arm64两种架构的符号表。其中arm64的偏移地址时835520</p>
<h4 id="3，UUID"><a href="#3，UUID" class="headerlink" title="3，UUID"></a>3，UUID</h4><p>每一个可执行程序都有一个build UUID来唯一标识。Crash日志包含发生crash的这个应用（app）的 build UUID以及crash发生的时候，应用加载的所有库文件的[build UUID]。UUID用来确定二进制包唯一标识</p>
<ul>
<li>查看日志文件的UUID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">localhost:Test guogunhua$ grep &quot;crashTest arm64&quot; crashTest2017.crash </div><div class="line">0x1000cc000 - 0x1000d3fff crashTest arm64  &lt;87f22ef6f56d3c7fac969d3416cd328a&gt; /var/containers/Bundle/Application/13B84A6F-FB06-484B-8573-9390559A4A71/crashTest.app/crashTest</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">localhost:Test guogunhua$ grep --after-context=2 &quot;Binary Images:&quot; crashTest2017.crash </div><div class="line">Binary Images:</div><div class="line">0x1000cc000 - 0x1000d3fff crashTest arm64  &lt;87f22ef6f56d3c7fac969d3416cd328a&gt; /var/containers/Bundle/Application/13B84A6F-FB06-484B-8573-9390559A4A71/crashTest.app/crashTest</div><div class="line">0x100124000 - 0x100153fff dyld arm64  &lt;f54ed85a94253887886a8028e20ed8ba&gt; /usr/lib/dyld</div></pre></td></tr></table></figure>
<p>其中 0x1000cc000 就是模块的加载地址。</p>
<ul>
<li>查看二进制文件的UUID,dSYM文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">localhost:Test guogunhua$ xcrun dwarfdump --uuid dSYMs/crashTest.app.dSYM/Contents/Resources/DWARF/crashTest </div><div class="line">UUID: 6D16D164-DA42-31C8-8890-94895DB43C47 (armv7) dSYMs/crashTest.app.dSYM/Contents/Resources/DWARF/crashTest</div><div class="line">UUID: 87F22EF6-F56D-3C7F-AC96-9D3416CD328A (arm64) dSYMs/crashTest.app.dSYM/Contents/Resources/DWARF/crashTest</div></pre></td></tr></table></figure>
<p>或者appName.app／appName文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">localhost:Test guogunhua$ xcrun dwarfdump --uuid Products/Applications/crashTest.app/crashTest </div><div class="line">UUID: 6D16D164-DA42-31C8-8890-94895DB43C47 (armv7) Products/Applications/crashTest.app/crashTest</div><div class="line">UUID: 87F22EF6-F56D-3C7F-AC96-9D3416CD328A (arm64) Products/Applications/crashTest.app/crashTest</div></pre></td></tr></table></figure>
<p>需要三者的UUID的匹配才能正确的符号化。即都是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 三，符号化iOS Crash堆栈</div><div class="line">我们拿到的crash信息是堆栈调用信息，所有信息都是16进制的内存地址，不能分析应用crash的原因，需要符号化才能分析。</div><div class="line">### 1，使用Xcode</div><div class="line">对于已经上架了appStore的应用的来说，crash文件通过用户上传到苹果服务器，Xcode可以直接下载下来，看到堆栈符号化的堆栈信息就和开发调试一样方便。  </div><div class="line">![](http://upload-images.jianshu.io/upload_images/1290895-f50fc476b2d470a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">### 2, symbolicatecrash</div><div class="line">symbolicatecrash是Xcode带的独立工具，可以拷贝出来使用。查找位置</div></pre></td></tr></table></figure></p>
<p>localhost:~ guogunhua$ find /Applications/Xcode.app -name symbolicatecrash -type f<br>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">把symbolicatecrash和奔溃日志，APP对应的.dSYM文件放在同一文件夹下，执行如下命令：</div></pre></td></tr></table></figure>
<p>Symbolicatecrash + 崩溃日志.crash + APP对应的.dSYM文件 + &gt; + 输出到的文件，<br>或者<br>Symbolicatecrash + 崩溃日志.crash + appName.app/appName + &gt; + 输出到的文件，<br>如：<br>localhost:Test guogunhua$ ./symbolicatecrash crashTest2017.crash Products/Applications/crashTest.app/crashTest &gt; aa.log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">符号化前</div></pre></td></tr></table></figure></p>
<p>Last Exception Backtrace:<br>0   CoreFoundation                    0x1843391b8 <strong>exceptionPreprocess + 124<br>1   libobjc.A.dylib                   0x182d7055c objc_exception_throw + 56<br>2   CoreFoundation                    0x1842147f4 -[</strong>NSArrayI objectAtIndex:] + 184<br>3   crashTest                         0x1000d0904 0x1000cc000 + 18692<br>4   crashTest                         0x1000d0864 0x1000cc000 + 18532<br>5   UIKit                             0x18a1ee924 -[UIViewController loadViewIfRequired] + 1056<br>6   UIKit                             0x18a1ee4ec -[UIViewController view] + 28<br>7   UIKit                             0x18a1f4c98 -[UIWindow addRootViewControllerViewIfPossible] + 76<br>8   UIKit                             0x18a1f2138 -[UIWindow _setHidden:forced:] + 272</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">symbolicatecrash 符号化后</div></pre></td></tr></table></figure>
<p>Last Exception Backtrace:<br>0   CoreFoundation                    0x1843391b8 <strong>exceptionPreprocess + 124<br>1   libobjc.A.dylib                   0x182d7055c objc_exception_throw + 56<br>2   CoreFoundation                    0x1842147f4 -[</strong>NSArrayI objectAtIndex:] + 184<br>3   crashTest                         0x1000d0904 -[ViewController crashTest] (ViewController.m:29)<br>4   crashTest                         0x1000d0864 -[ViewController viewDidLoad] (ViewController.m:22)<br>5   UIKit                             0x18a1ee924 -[UIViewController loadViewIfRequired] + 1056<br>6   UIKit                             0x18a1ee4ec -[UIViewController view] + 28<br>7   UIKit                             0x18a1f4c98 -[UIWindow addRootViewControllerViewIfPossible] + 76<br>8   UIKit                             0x18a1f2138 -[UIWindow _setHidden:forced:] + 272<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看到第3，4行已经符号化了，显示了哪个文件具体行数，对应代码</div><div class="line">![](http://upload-images.jianshu.io/upload_images/1290895-b2d30b3ee626bcef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">查看源码，找出代码crash的原因就容易的多了。但使用symbolicatecrash工具有很大的限制</div><div class="line"></div><div class="line">- 只能分析官方格式的崩溃日志，需要从具体的设备中导出，获取和操作都不是很方便</div><div class="line">- 符号化的结果也是没有具体的行号信息的，也经常会出现符号化失败的情况。</div><div class="line">- 实际上, Xcode的Organizer内置了symbolicatecrash工具，所以开发者才可以直接看到符号化的崩溃堆栈日志。</div><div class="line"></div><div class="line">### 3，使用命令行工具atos</div><div class="line">命令格式：</div></pre></td></tr></table></figure></p>
<p> atos -o executable -arch architecture -l loadAddress address<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">说明：  </div><div class="line"></div><div class="line">- executable dYSM文件或二进制执行文件appName.app/appName</div><div class="line">- loadAddress 表示函数的动态加载地址，对应崩溃地址堆栈中 + 号前面的地址，即0x1000cc000</div><div class="line">- address 表示运行时地址、对应崩溃地址堆栈中第一个地址，即0x1000d0904  ，实际上，崩溃地址堆栈中+号前后的地址相加即是运行时地址，即0x1000cc000 + 18692= 0x1000d0904</div><div class="line">- 执行命令查询地址的符号，可以看到如下结果：</div></pre></td></tr></table></figure></p>
<p>-[ViewController crashTest] (in crashTest) (ViewController.m:29)<br>```</p>
<h2 id="四，总结"><a href="#四，总结" class="headerlink" title="四，总结"></a>四，总结</h2><p>本文分析了如何获取用户的.crash文件，以及如何符号化的方法，对于分析应用crash很适用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/14/super/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/14/super/" itemprop="url">
                  super关键字帮我们做了什么？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-14T22:44:53+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>作者：戴奕</p>
</blockquote>
<p>本篇文章讲的是super的实际运作原理，如有同学对super与self的区分还有疑惑的，请参考ChenYilong大神的<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#21-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88">《招聘一个靠谱的iOS》面试题参考答案（上）</a>。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/14/super/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/replicatorLayer/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/replicatorLayer/" itemprop="url">
                  CAReplicatorLayer创建加载动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T16:24:26+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：周思思</p>
</blockquote>
<ul>
<li><strong>介绍：</strong>官方文档里写的是：<strong>“A layer that creates a specified number of copies of its sublayers (the source layer), each copy potentially having geometric, temporal, and color transformations applied to it.”</strong><br>简单的说它可以拷贝子layer，并和拷贝的子layer拥有一样的功能，比如属性、位置、形变、动画。进行一些不同的属性设置我们可以让它完成一些非常炫酷的动画。</li>
</ul>
<ul>
<li><strong>代码参考：</strong><a href="http://code.cocoachina.com/view/133667" target="_blank" rel="external">http://code.cocoachina.com/view/133667</a></li>
<li><p><strong>效果：</strong></p>
<p><img src="/img/replicatorLayer/replicatorLayer1.gif" alt="img"></p>
</li>
</ul>
<h2 id="CAReplicatorLayer的属性"><a href="#CAReplicatorLayer的属性" class="headerlink" title="CAReplicatorLayer的属性"></a>CAReplicatorLayer的属性</h2><p>想要了解一个对象最简单的入手点就是了解它的属性和方法</p>
<p><strong>CAReplicatorLayer</strong> 的属性和方法并不多，主要是：</p>
<p><img src="/img/replicatorLayer/replicatorLayer2.jpg" alt="MacDown Screenshot"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-创建一个layer"><a href="#1-创建一个layer" class="headerlink" title="1.创建一个layer"></a>1.创建一个layer</h3><p><img src="/img/replicatorLayer/replicatorLayer3.jpg" alt="MacDown Screenshot"></p>
<h3 id="2-给layer添加形变动画"><a href="#2-给layer添加形变动画" class="headerlink" title="2.给layer添加形变动画"></a>2.给layer添加形变动画</h3><p><img src="/img/replicatorLayer/replicatorLayer4.jpg" alt="MacDown Screenshot"></p>
<h3 id="3-利用CAReplicatorLayer拷贝多个layer进行动画"><a href="#3-利用CAReplicatorLayer拷贝多个layer进行动画" class="headerlink" title="3.利用CAReplicatorLayer拷贝多个layer进行动画"></a>3.利用CAReplicatorLayer拷贝多个layer进行动画</h3><p><img src="/img/replicatorLayer/replicatorLayer5.jpg" alt="MacDown Screenshot"></p>
<h3 id="4-将创建的CAReplicatorLayer添加到所需的layer上"><a href="#4-将创建的CAReplicatorLayer添加到所需的layer上" class="headerlink" title="4.将创建的CAReplicatorLayer添加到所需的layer上"></a>4.将创建的CAReplicatorLayer添加到所需的layer上</h3><p><img src="/img/replicatorLayer/replicatorLayer6.jpg" alt="MacDown Screenshot"></p>
<h4 id="就这样，所需的加载效果的动画就完成了。"><a href="#就这样，所需的加载效果的动画就完成了。" class="headerlink" title="就这样，所需的加载效果的动画就完成了。"></a>就这样，所需的加载效果的动画就完成了。</h4><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>分享几个讲解CAReplicatorLayer比较详细的blog以及demo，需要的可以再去加深了解，它能完成很多强大的动画</p>
<p><a href="http://www.ios-animations-by-emails.com/posts/2015-march#tutorial" target="_blank" rel="external">http://www.ios-animations-by-emails.com/posts/2015-march#tutorial</a><br><a href="https://zsisme.gitbooks.io/ios-/content/chapter6/careplicatorLayer.html" target="_blank" rel="external">https://zsisme.gitbooks.io/ios-/content/chapter6/careplicatorLayer.html</a><br><a href="https://github.com/zhoubo2015/CAReplicatorLayerDemo" target="_blank" rel="external">https://github.com/zhoubo2015/CAReplicatorLayerDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/iOS链式编程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/iOS链式编程/" itemprop="url">
                  链式编程简单的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T15:35:34+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：邵雄华</p>
</blockquote>
<p>  链式编程－顾名思义，链式，连贯性为其主要特征，放在编程领域来讲，说简单点就是把一系列的代码执行动作串联起来，不用单独一个一个的执行<br>在使用 Masonry 和 SDAutoLayout 框架实现自动布局的时候，进行了对比</p>
<h4 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry:"></a>Masonry:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[View mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">      make.top.equalTo(anotherView);</div><div class="line">      make.left.equalTo(anotherView);</div><div class="line">      make.width.mas_equalTo(@60);</div><div class="line">      make.height.mas_equalTo(@60);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="SDAutoLayout"><a href="#SDAutoLayout" class="headerlink" title="SDAutoLayout:"></a>SDAutoLayout:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">View.sd_layout</div><div class="line">.leftSpaceToView(self.view, 10)</div><div class="line">.topSpaceToView(self.view, 80)</div><div class="line">.heightIs(130)</div><div class="line">.widthRatioToView(self.view, 0.4);</div></pre></td></tr></table></figure>
<p>相比较两种实现方法来看，SDAutoLayout相对来说更简单，代码量更少，也更容易理解和使用！</p>
<p>这里说一下我对这两个框架的一点理解<br>Masonry 和 SDAutoLayout 实现思路：链式编程思想。</p>
<h4 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h4><ul>
<li><p>链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
</li>
<li><p>链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
</li>
<li><p>代表：Masonry框架、SDAutoLayout框架</p>
</li>
</ul>
<h3 id="链式编程另一个关键点－－block："><a href="#链式编程另一个关键点－－block：" class="headerlink" title="链式编程另一个关键点－－block："></a>链式编程另一个关键点－－block：</h3><h5 id="Block的定义格式"><a href="#Block的定义格式" class="headerlink" title="Block的定义格式"></a>Block的定义格式</h5><p>返回值类型(^block变量名)(形参列表) = ^(形参列表) {<br>};<br>调用Block保存的代码<br>block变量名(实参);</p>
<p>默认情况下,Block内部不能修改外面的局部变量<br>Block内部可以修改使用__block修饰的局部变量</p>
<h5 id="Block的模式"><a href="#Block的模式" class="headerlink" title="Block的模式"></a>Block的模式</h5><p>1.无参数无返回值的Block<br>2.有参数无返回值的Block<br>3.有参数有返回值的Block</p>
<p>Block简单用法举例</p>
<p>无参数无返回值的Block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  无参数无返回值的Block</div><div class="line"> */</div><div class="line">- (void)func1 &#123;</div><div class="line">    /**</div><div class="line">     *  void ：就是无返回值</div><div class="line">     *  emptyBlock：就是该block的名字</div><div class="line">     *  ()：这里相当于放参数。由于这里是无参数，所以就什么都不写</div><div class="line">     */</div><div class="line">    void (^emptyBlock)() = ^()&#123;</div><div class="line">        NSLog(@&quot;无参数,无返回值的Block&quot;);</div><div class="line">    &#125;;</div><div class="line">    emptyBlock();</div><div class="line">&#125;</div><div class="line">有参数无返回值的Block</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     *  调用这个block进行两个参数相加</div><div class="line">     *</div><div class="line">     *  @param int 参数A</div><div class="line">     *  @param int 参数B</div><div class="line">     *</div><div class="line">     *  @return 无返回值</div><div class="line">     */</div><div class="line">    void (^sumBlock)(int ,int ) = ^(int a,int b)&#123;</div><div class="line">        NSLog(@&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class="line">    &#125;;</div><div class="line">    /**</div><div class="line">     *  调用这个sumBlock的Block，得到的结果是20</div><div class="line">     */</div><div class="line">    sumBlock(10,10);</div><div class="line">有参数有返回值的Block</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     *  有参数有返回值</div><div class="line">     *</div><div class="line">     *  @param NSString 字符串1</div><div class="line">     *  @param NSString 字符串2</div><div class="line">     *</div><div class="line">     *  @return 返回拼接好的字符串3</div><div class="line">     */    </div><div class="line">    NSString* (^logBlock)(NSString *,NSString *) = ^(NSString * str1,NSString *str2)&#123;</div><div class="line">        return [NSString stringWithFormat:@&quot;%@%@&quot;,str1,str2];</div><div class="line">    &#125;;</div><div class="line">    //调用logBlock,输出的是 我是Block</div><div class="line">    NSLog(@&quot;%@&quot;, logBlock(@&quot;我是&quot;,@&quot;Block&quot;));</div></pre></td></tr></table></figure>
<h5 id="Block结合typedef使用"><a href="#Block结合typedef使用" class="headerlink" title="Block结合typedef使用"></a>Block结合typedef使用</h5><p>自己定义一个Block类型，用定义的类型去创建Block，更加简单便捷。</p>
<p>这里举一个例子 UIButton 的链式编程实现</p>
<h6 id="CHButton-h"><a href="#CHButton-h" class="headerlink" title="CHButton.h"></a>CHButton.h</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  CHButton.h</div><div class="line">//  testDemo</div><div class="line">//</div><div class="line">//  Created by 邵雄华 on 2017/4/13.</div><div class="line">//  Copyright © 2017年 sxh. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@class CHButton;</div><div class="line"></div><div class="line">//typedef一个返回值为CHButton* 参数为NSString* 的名字为ChainButtonStringBlock的block,方便以后快速定义该类型block</div><div class="line"></div><div class="line">typedef CHButton *(^ChainButtonStringBlock)(NSString *aName);</div><div class="line"></div><div class="line">typedef CHButton *(^ChainButtonIntegerBlcok)(NSUInteger aNumber);</div><div class="line"></div><div class="line">typedef CHButton *(^ChainButtonColorBlock)(UIColor *aColor);</div><div class="line"></div><div class="line">typedef CHButton *(^ChainButtonFrameBlock)(CGRect aframe);</div><div class="line"></div><div class="line">@interface CHButton : UIButton</div><div class="line"></div><div class="line"></div><div class="line">- (ChainButtonStringBlock)imageName;</div><div class="line"></div><div class="line">- (ChainButtonStringBlock)title;</div><div class="line"></div><div class="line">- (ChainButtonIntegerBlcok)titleFont;</div><div class="line"></div><div class="line">- (ChainButtonColorBlock)textColor;</div><div class="line"></div><div class="line">- (ChainButtonFrameBlock)btnframe;</div><div class="line"></div><div class="line"></div><div class="line">//该方法为工厂方法,能够快速创建一个ChainButton,在一个参数为block的方法中一次性设置好你需要的ChainButton</div><div class="line">+ (CHButton *)makeJJButton:(void (^)(CHButton *))block;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h6 id="CHButton-m"><a href="#CHButton-m" class="headerlink" title="CHButton.m"></a>CHButton.m</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  CHButton.m</div><div class="line">//  testDemo</div><div class="line">//</div><div class="line">//  Created by 邵雄华 on 2017/4/13.</div><div class="line">//  Copyright © 2017年 sxh. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;CHButton.h&quot;</div><div class="line"></div><div class="line">@implementation CHButton</div><div class="line"></div><div class="line">- (ChainButtonStringBlock)imageName&#123;</div><div class="line">    return ^CHButton *(NSString *aName)&#123;</div><div class="line">        [self setImage:[UIImage imageNamed:aName] forState:UIControlStateNormal];</div><div class="line">        NSLog(@&quot;imageName&quot;);</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (ChainButtonStringBlock)title&#123;</div><div class="line">    return ^CHButton *(NSString *aName)&#123;</div><div class="line">        [self setTitle:aName forState:UIControlStateNormal];</div><div class="line">        NSLog(@&quot;title&quot;);</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (ChainButtonIntegerBlcok)titleFont&#123;</div><div class="line">    return ^CHButton *(NSUInteger aNumber)&#123;</div><div class="line">        self.titleLabel.font = [UIFont systemFontOfSize:aNumber];</div><div class="line">        NSLog(@&quot;titleFont&quot;);</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (ChainButtonColorBlock)textColor&#123;</div><div class="line">    return ^CHButton *(UIColor *aColor)&#123;</div><div class="line">        [self setTitleColor:aColor forState:UIControlStateNormal];</div><div class="line">        NSLog(@&quot;textColor = %@&quot;,aColor);</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (ChainButtonFrameBlock)btnframe&#123;</div><div class="line">    return ^CHButton *(CGRect btnframe)&#123;</div><div class="line">        [self setFrame:btnframe];</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (CHButton *)makeJJButton:(void (^)(CHButton *))block&#123;</div><div class="line">    CHButton * button = [[CHButton alloc] init];</div><div class="line">    block(button);</div><div class="line">    return button;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="使用方法-利用工厂模式创建一个CHButton"><a href="#使用方法-利用工厂模式创建一个CHButton" class="headerlink" title="使用方法:利用工厂模式创建一个CHButton"></a>使用方法:利用工厂模式创建一个CHButton</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[CHButton makeJJButton:^(CHButton *button) &#123;</div><div class="line">        button.title(@&quot;xixixi&quot;).imageName(@&quot;abc&quot;).titleFont(20).textColor([UIColor orangeColor]).btnframe(CGRectMake(100, 100, 100, 100));</div><div class="line">        button.frame = CGRectMake(100, 250, 100, 100);</div><div class="line">        [self.view addSubview:button];</div><div class="line">        [button addTarget:self action:@selector(didClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>链式编程要返回自身，每一个链式方法都必须返回明确的类型才能一直点下去，使用protocol或继承都不行，必须在每一个方法的声明时明确返回对象的类型。所以链式文件中不但有该类的方法声明，也有父类的方法声明。</p>
<p>后续会对更多的类进行链式的一种封装，提高开发的效率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-Git " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/关于Git的使用过程中的一些不必要的文件的提交/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/关于Git的使用过程中的一些不必要的文件的提交/" itemprop="url">
                  关于Git的使用过程中的一些不必要的文件的提交
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T11:31:33+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> 作者：邵雄华</p>
</blockquote>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><h4 id="1-cd到工程目录"><a href="#1-cd到工程目录" class="headerlink" title="1. cd到工程目录"></a>1. cd到工程目录</h4><p>cd /Users/shaoxionghua/ios/test</p>
<h4 id="2-status一下"><a href="#2-status一下" class="headerlink" title="2. status一下"></a>2. status一下</h4><p>git status<br>（ps：会出现一下类似的东西）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  On branch develop</div><div class="line">Your branch is up-to-date with &apos;origin/develop&apos;.</div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line">	modified:   .DS_Store</div><div class="line">	modified:   Live.xcworkspace/xcuserdata/shaoxionghua.xcuserdatad/UserInterfaceState.xcuserstate</div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div></pre></td></tr></table></figure>
<h4 id="3-rm这些不需要的文件或者路径"><a href="#3-rm这些不需要的文件或者路径" class="headerlink" title="3. rm这些不需要的文件或者路径"></a>3. rm这些不需要的文件或者路径</h4><p>git rm –cached .DS_Store<br>  git rm –cached Live.xcworkspace/xcuserdata/shaoxionghua.xcuserdatad/UserInterfaceState.xcuserstate</p>
<h4 id="4-提交这些变更"><a href="#4-提交这些变更" class="headerlink" title="4. 提交这些变更"></a>4. 提交这些变更</h4><p>git commit -m ‘ignore’</p>
<h4 id="5-最好执行一下pull和push"><a href="#5-最好执行一下pull和push" class="headerlink" title="5. 最好执行一下pull和push"></a>5. 最好执行一下pull和push</h4><p>git pull<br>git push</p>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><h4 id="1-cd到工程目录-1"><a href="#1-cd到工程目录-1" class="headerlink" title="1. cd到工程目录"></a>1. cd到工程目录</h4><p>cd /Users/shaoxionghua/ios/test</p>
<h4 id="2-修改-gitignore文件"><a href="#2-修改-gitignore文件" class="headerlink" title="2. 修改.gitignore文件"></a>2. 修改.gitignore文件</h4><p>一般常见的一些设置如下：<br>(ps:在.gitignore文件里面写入如下内容，不要问我这个文件在哪里，不要问我怎么打开它，方法请自行百度或者google)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*.xcuserstate  </div><div class="line">project.xcworkspace  </div><div class="line">xcuserdata  </div><div class="line">UserInterfaceState.xcuserstate  </div><div class="line">project.xcworkspace/  </div><div class="line">xcuserdata/  </div><div class="line">UserInterface.xcuserstate</div><div class="line">*.DS_Store</div></pre></td></tr></table></figure>
<h4 id="3-提交修改gitignore文件"><a href="#3-提交修改gitignore文件" class="headerlink" title="3. 提交修改gitignore文件"></a>3. 提交修改gitignore文件</h4><p>git rm -r –cached .<br>git add .<br>git commit -m ‘update .gitignore’</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-iOS组件化 " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/大象iOS组件化调研（一）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="jcapp">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/jc_logo.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="金诚App团队blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="金诚App团队blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/大象iOS组件化调研（一）/" itemprop="url">
                  大象iOS组件调研（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T09:23:35+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：华文杰</p>
</blockquote>
<ol>
<li><p>组件化概念</p>
<ul>
<li><p>什么是组件化？</p>
<p>“组件”一般来说用于命名比较小的功能块，如：下拉刷新组件，提示框组件。而较大的业务功能则称为”模块“。</p>
<p>而一般iOS中的组件化只的是模块和组件的结合（个人理解），或者这两者之间本身就不应该有过于明确的界限</p>
<blockquote>
<p>从工程代码层面来说，组件化得实施通常是通过中间件解决组件间文件直接引用的、依赖混乱的问题；从实际开发来说，组件间最大的需求就是页面跳转，需要从组件A的pageA页面跳到组件B的pageB页面，避免ViewController头文件的直接依赖。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>为什么要组件?</p>
<ul>
<li>组件化解决了什么问题。<ul>
<li>就iOS 而言，解耦了VC，使代码的管理及维护成本更低（长期维护，多人接手）</li>
<li>此外组件化可以提高开发效率（开发者只需关心自己的组件）</li>
<li>这也符合编程的封装性，以及面向对象（更深入的理解，一切皆对象）</li>
<li>方便测试。</li>
<li>提高代码可复用性，多个APP时可使用相同的代码</li>
</ul>
</li>
</ul>
</li>
<li><p>如何划分组件？</p>
<ul>
<li>基础组件（一般是第三方控件，自己的功用控件，与业务不太相关）</li>
<li>基础业务SDK （可以跨APP，例如登录模块，建议组件化时分为View 和 Model 分离）</li>
<li>个性业务组件（一般以业务为划分）</li>
</ul>
</li>
<li><p>对于没有实施过组件化的工程来说，应该如何开始呢？</p>
<ul>
<li>基础模块拆分。如，性能统计，NewWorking，Patch，网络请求，数据存储，</li>
<li>业务模块划分。一般登录可以先拆分，之后再以基本的模块拆分，一般以Tabbar为划分</li>
</ul>
</li>
<li><p>组件拆分的技术要点</p>
<ul>
<li><p>代码可以用CocosPods 配合 git做代码管理 物理拆分</p>
</li>
<li><p>而组件间如何解耦的话</p>
<p>有兴趣可以看看蘑菇街的方案，和安居客的方案。个人是建议安居客的方案</p>
</li>
</ul>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jc_logo.png"
               alt="jcapp" />
          <p class="site-author-name" itemprop="name">jcapp</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jcapp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
